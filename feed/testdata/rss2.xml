<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
        >

    <channel>
        <title>Matrix67: The Aha Moments</title>
        <atom:link href="http://www.matrix67.com/blog/feed" rel="self" type="application/rss+xml"/>
        <link>http://www.matrix67.com/blog</link>
        <description></description>
        <lastBuildDate>Mon, 07 Sep 2015 23:39:26 +0000</lastBuildDate>
        <language>en-US</language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
        <generator>http://wordpress.org/?v=4.2.4</generator>
        <item>
            <title>趣题：每个小点最后都会回到自己原来的位置上吗？</title>
            <link>http://www.matrix67.com/blog/archives/6504</link>
            <comments>http://www.matrix67.com/blog/archives/6504#comments</comments>
            <pubDate>Mon, 07 Sep 2015 20:31:14 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6504</guid>
            <description>
                <![CDATA[最近，来自 wavegrower 的一张 gif 动画红遍了 reddit 。有人提出了这么一个问题：每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 答案是肯定的。 math 版上的 OmnipotentEntity 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。 熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。]]></description>
            <content:encoded><![CDATA[<p>最近，来自 <a href="http://wavegrower.tumblr.com/post/126854522925/currents-if-i-had-the-time-i-would-check-if-one-of">wavegrower</a> 的一张 gif 动画红遍了 <a href="https://www.reddit.com/r/woahdude/comments/3hys1f/try_and_follow_one/">reddit</a> 。有人提出了这么一个问题：每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201509081.gif" alt="" width="500" /></p>
<p><span id="more-6504"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>答案是肯定的。 math 版上的 <a href="https://www.reddit.com/r/math/comments/3hz9u9/will_each_jellyfish_in_this_gif_eventually_end_up/cubw779">OmnipotentEntity</a> 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。</p>
<p>熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6504/feed</wfw:commentRss>
            <slash:comments>9</slash:comments>
        </item>
        <item>
            <title>Keller 猜想与 12 维空间中的神构造</title>
            <link>http://www.matrix67.com/blog/archives/6487</link>
            <comments>http://www.matrix67.com/blog/archives/6487#comments</comments>
            <pubDate>Sun, 06 Sep 2015 16:36:29 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[几何]]></category>
            <category><![CDATA[动画]]></category>
            <category><![CDATA[惊奇数学事实]]></category>
            <category><![CDATA[组合数学]]></category>
            <category><![CDATA[证明]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6487</guid>
            <description>
                <![CDATA[在各种令人惊讶的数学事实当中，我最喜欢的类型之一便是，某个数学命题在二维空间、三维空间甚至四维空间当中都是成立的，但偏偏到了某个维度时，命题就不成立了。 Keller 猜想就是一个这样的例子。 同样大小的正方形平铺整个平面（比如像下图那样），则一定存在某些边与边完全贴合的相邻正方形。 类似地，同样大小的正方体平铺整个空间（比如像下图那样），则一定存在某些面与面完全贴合的相邻正方体。 1930 年， Ott-Heinrich Keller 猜测，或许这一点对于更高维度的空间都是成立的。也就是说， Ott-Heinrich Keller 猜测，对于任意正整数 n ≥ 2 都有，同样大小的 n 维立方体平铺整个 n 维空间，则一定有两个面与面完全贴合的相邻 n 维立方体。这就是著名的 Keller 猜想。 1940 年， Oskar Perron 证明了，当 n = 2, 3, 4, 5, 6 时， Keller 猜想确实是正确的。一切似乎都在正轨上。然而，到了 1992 年的时候，事情出现了转折： Jeffrey Lagarias 和 Peter Shor 构造了一个 n = 12 时的反例，从而推翻了 Keller 猜想。让我们来看一看 Lagarias [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>在各种令人惊讶的数学事实当中，我最喜欢的类型之一便是，某个数学命题在二维空间、三维空间甚至四维空间当中都是成立的，但偏偏到了某个维度时，命题就不成立了。 Keller 猜想就是一个这样的例子。</p>
<p>同样大小的正方形平铺整个平面（比如像下图那样），则一定存在某些边与边完全贴合的相邻正方形。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201509061.png" alt="" width="360" /></p>
<p>类似地，同样大小的正方体平铺整个空间（比如像下图那样），则一定存在某些面与面完全贴合的相邻正方体。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201509062.png" alt="" width="400" /></p>
<p>1930 年， Ott-Heinrich Keller 猜测，或许这一点对于更高维度的空间都是成立的。也就是说， Ott-Heinrich Keller 猜测，对于任意正整数 n ≥ 2 都有，同样大小的 n 维立方体平铺整个 n 维空间，则一定有两个面与面完全贴合的相邻 n 维立方体。这就是著名的 Keller 猜想。</p>
<p>1940 年， Oskar Perron 证明了，当 n = 2, 3, 4, 5, 6 时， Keller 猜想确实是正确的。一切似乎都在正轨上。然而，到了 1992 年的时候，事情出现了转折： Jeffrey Lagarias 和 Peter Shor 构造了一个 n = 12 时的反例，从而推翻了 Keller 猜想。让我们来看一看 Lagarias 和 Shor 的神构造吧。为了方便起见，下面我们直接用“立方体”一词指代 n 维的广义立方体，“立方体的面”则代表 n 维立方体的 n &#8211; 1 维面。</p>
<p><span id="more-6487"></span>&nbsp;</p>
<p>考虑所有只用 0 、 1 、 2 、 3 四个数组成的 n 维坐标，这样的坐标一共有 4<sup>n</sup> 个。现在，从中选择其中的 2<sup>n</sup> 个坐标，使得每两个坐标都有至少一个位置上的数相差正好为 2 。把这些坐标当作立方体的中心，作出一个个边长为 2 的立方体。容易看出，这些立方体将会满足：</p>
<ul>
<li>任意两个立方体都不会有重合的部分；</li>
<li>即使这些立方体可以沿着各坐标轴方向 4 格 4 格地任意平移，任意两个立方体也仍然不会有重合的部分（本来相差 2 个单位的维度上仍然会差至少 2 个单位）；</li>
<li>这些立方体的总体积是 2<sup>n</sup> · 2<sup>n</sup> = 4<sup>n</sup> ，正好等于一个边长为 4 的大立方体的体积。</li>
</ul>
<p>因而，把这些立方体当作一个整体，沿着各坐标轴方向 4 格 4 格地平移，就能平铺整个空间了。不过，这样得到的平铺方案中，可能存在着完全贴合的相邻立方体。然而，如果我们选出的 2<sup>n</sup> 个坐标当中，每两个坐标之间不但有某个位置上的数正好相差 2 ，还有另外至少一个位置上的数也不同的话，那么相邻立方体就都是错开的了——即使平移之后，该错开的立方体仍然是错开的，因为 0 、 1 、 2 、 3 四个数当中的任意两个不同的数，不会因为它们各自加减了某些 4 的倍数而变得相同。</p>
<p>如果两个 n 维坐标满足，它们有至少一个维度上的坐标正好相差 2 ，而且还有至少一个维度上的坐标不同，我们就说这两个 n 维坐标是相容的。因此，为了构造出一个 n 维空间中 Keller 猜测的反例，我们只需要找出 2<sup>n</sup> 个由 0 、 1 、 2 、 3 四个数组成的 n 维坐标，使得里面的任意两个坐标都是相容的，</p>
<p>为了更好地说明上面这些话的意思，让我们来看一个 n = 3 时的例子。由 0 、 1 、 2 、 3 四个数组成的三维坐标一共有 4<sup>3</sup> = 64 个，我们选择以下 2<sup>3</sup> = 8 个：</p>
<ul>
<li>(0, 0, 0)</li>
<li>(2, 0, 1)</li>
<li>(1, 2, 0)</li>
<li>(0, 1, 2)</li>
<li>(2, 0, 3)</li>
<li>(3, 2, 0)</li>
<li>(0, 3, 2)</li>
<li>(2, 2, 2)</li>
</ul>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201509063.gif" alt="" width="420" /></p>
<p>注意到，上面这 8 个坐标中，每两个坐标都有至少一个位置上的数正好相差 2 。如果以它们为中心，作出一个个边长为 2 的立方体，你会发现不管从哪个方向上看，这些立方体排成的都是紧密的两层。因此，使用这种结构的组合体，就能平铺整个空间了。只可惜，在上面这 8 个坐标中， (2, 0, 1) 和 (2, 0, 3) 虽然有一个位置上正好相差 2 ，但在其他位置上的数都是相同的。因此，这两个坐标所对应的立方体就是完全贴合的。类似的情况还有 (1, 2, 0) 和 (3, 2, 0) ，以及 (0, 1, 2) 和 (0, 3, 2) 。因此，这 8 个坐标并不构成 n = 3 时 Keller 猜想的反例。不过， Lagarias 和 Shor 却以此为基础，成功构造出了 n = 12 时 Keller 猜想的反例。让我们暂时把 (2, 0, 3) 、 (3, 2, 0) 和 (0, 3, 2) 中的 0 替换成 0′ ，并且规定 0′ 和 0 是两个数值相等的不同元素。这样赖皮之后，这 8 个坐标暂时变得两两相容了：</p>
<ul>
<li>(0, 0, 0)</li>
<li>(2, 0, 1)</li>
<li>(1, 2, 0)</li>
<li>(0, 1, 2)</li>
<li>(2, 0′, 3)</li>
<li>(3, 2, 0′)</li>
<li>(0′, 3, 2)</li>
<li>(2, 2, 2)</li>
</ul>
<p>现在，我们要把它们变成 2<sup>12</sup> = 4096 个十二维坐标，使得所有坐标仍然是两两相容，并且里面不再有 0′ 这种东西。考虑 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 这么五个集合，每个集合里面都有若干个四维坐标。这五个集合的具体情况如下：</p>
<table>
<tr>
<td>S<sub>0</sub></td>
<td>S<sub>0′</sub></td>
<td>S<sub>1</sub></td>
<td>S<sub>2</sub></td>
<td>S<sub>3</sub></td>
</tr>
<tr>
<td>(0, 0, 0, 0)</td>
<td>(0, 3, 0, 3)</td>
<td>(1, 0, 0, 0)</td>
<td>(0, 2, 1, 1)</td>
<td>(1, 2, 1, 1)</td>
</tr>
<tr>
<td>(0, 0, 1, 2)</td>
<td>(1, 0, 1, 1)</td>
<td>(1, 0, 1, 2)</td>
<td>(1, 1, 3, 2)</td>
<td>(2, 1, 3, 2)</td>
</tr>
<tr>
<td>(0, 2, 1, 3)</td>
<td>(1, 1, 1, 3)</td>
<td>(1, 2, 1, 3)</td>
<td>(2, 3, 0, 3)</td>
<td>(3, 3, 0, 3)</td>
</tr>
<tr>
<td>(0, 2, 3, 0)</td>
<td>(1, 1, 3, 0)</td>
<td>(1, 2, 3, 0)</td>
<td>(3, 0, 2, 0)</td>
<td>(0, 0, 2, 0)</td>
</tr>
<tr>
<td>(0, 3, 3, 2)</td>
<td>(1, 3, 2, 3)</td>
<td>(1, 3, 3, 2)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(1, 0, 2, 0)</td>
<td>(1, 3, 3, 1)</td>
<td>(2, 0, 2, 0)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(2, 1, 0, 0)</td>
<td>(2, 2, 1, 1)</td>
<td>(3, 1, 0, 0)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(2, 1, 1, 2)</td>
<td>(3, 0, 0, 1)</td>
<td>(3, 1, 1, 2)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(2, 2, 2, 0)</td>
<td>(3, 0, 2, 2)</td>
<td>(3, 2, 2, 0)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(2, 3, 0, 1)</td>
<td>(3, 1, 0, 3)</td>
<td>(3, 3, 0, 1)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(2, 3, 2, 2)</td>
<td>(3, 2, 2, 3)</td>
<td>(3, 3, 2, 2)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>(3, 1, 3, 2)</td>
<td>(3, 2, 3, 1)</td>
<td>(0, 1, 3, 2)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<p>可以验证，这五个集合满足以下 5 个条件。</p>
<ol>
<li>对于 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 中的任意一个集合，里面的所有四维坐标都是两两相容的。</li>
<li>对于 S<sub>0</sub> 、 S<sub>0′</sub> 、 S<sub>1</sub> 、 S<sub>2</sub> 、 S<sub>3</sub> 中的任意两个集合，里面都没有相同的四维坐标。</li>
<li>S<sub>0</sub> 中的每一个坐标和 S<sub>2</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
<li>S<sub>0′</sub> 中的每一个坐标和 S<sub>2</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
<li>S<sub>1</sub> 中的每一个坐标和 S<sub>3</sub> 中的每一个坐标相比，都有一个位置上正好相差 2 。</li>
</ol>
<p>这五个集合显然不是凭空构造出来的，绝大部分都是根据某些规律生成的。抓住这些规律，可以大大简化我们的验证工作。注意到， S<sub>1</sub> 可以看作是把 S<sub>0</sub> 里的每一个坐标的首位按照 {0 → 1, 1 → 2, 2 → 3, 3 → 0} 的规则进行替换后得来的， S<sub>3</sub> 也可以看作是对 S<sub>2</sub> 里的每一个坐标进行同样的变换后得来的。因此，如果 S<sub>0</sub> 中的坐标两两相容，则 S<sub>1</sub> 中的坐标也就两两相容了；如果 S<sub>2</sub> 中的坐标两两相容，则 S<sub>3</sub> 中的坐标也就两两相容了；还有，如果 S<sub>0</sub> 和 S<sub>2</sub> 满足条件 3 ，则 S<sub>1</sub> 和 S<sub>3</sub> 也一定满足条件 5 。另外， S<sub>0′</sub> 又可以看作是把 S<sub>0</sub> 里的每一个坐标的首位按照 {0 → 1, 1 → 2, 2 → 3, 3 → 0} 的规则进行替换，再把末位按照 {0 → 3, 3 → 2, 2 → 1, 1 → 0} 的规则进行替换，最后把这两位交换之后得来的。因此，如果 S<sub>0</sub> 中的坐标两两相容，则 S<sub>0′</sub> 中的坐标也就两两相容了。有趣的是，对 S<sub>2</sub> 里的所有坐标进行同样的变换后，得到的集合正好是它自己。因此， S<sub>0</sub> 和 S<sub>2</sub> 一旦满足条件 3，则 S<sub>0′</sub> 和 S<sub>2</sub> 也就自动地满足条件 4 了。最终，我们真正需要验证的就只有条件 2 和条件 3 ，以及条件 1 中的 S<sub>0</sub> 和 S<sub>2</sub> 这两个集合。如果你感兴趣的话，不妨自己验证一下。</p>
<p>还记得刚才那 8 个赖皮之后暂时变得两两相容的三维坐标吗？现在，从中任取一个坐标，将各个位置上的数都替换成对应集合里的某个四维坐标，我们就能够得到各种各样的十二维坐标了。例如， S<sub>2</sub> 里面有 4 个四维坐标， S<sub>0′</sub> 里面有 12 个四维坐标， S<sub>3</sub> 里面有 4 个四维坐标，因此从 (2, 0′, 3) 出发，一共就可以派生出 4 × 12 × 4 = 192 个十二维坐标。照这样做下去，我们一共能派生出多少个十二维坐标呢？让我们来算一算。</p>
<ul>
<li>(0, 0, 0)&nbsp;&nbsp;→&nbsp;&nbsp;12 × 12 × 12 = 1728</li>
<li>(2, 0, 1)&nbsp;&nbsp;→&nbsp;&nbsp;4 × 12 × 12 = 576</li>
<li>(1, 2, 0)&nbsp;&nbsp;→&nbsp;&nbsp;12 × 4 × 12 = 576</li>
<li>(0, 1, 2)&nbsp;&nbsp;→&nbsp;&nbsp;12 × 12 × 4 = 576</li>
<li>(2, 0′, 3)&nbsp;&nbsp;→&nbsp;&nbsp;4 × 12 × 4 = 192</li>
<li>(3, 2, 0′)&nbsp;&nbsp;→&nbsp;&nbsp;4 × 4 × 12 = 192</li>
<li>(0′, 3, 2)&nbsp;&nbsp;→&nbsp;&nbsp;12 × 4 × 4 = 192</li>
<li>(2, 2, 2)&nbsp;&nbsp;→&nbsp;&nbsp;4 × 4 × 4 = 64</li>
<li>总计： 1728 + 576 × 3 + 192 × 3 + 64 = 4096</li>
</ul>
<p>这正好等于 2<sup>12</sup> 。下面我们证明，这 2<sup>12</sup> 个十二维坐标是两两相容的。</p>
<p>容易看出，对于任意一个三维坐标来说，由它派生出来的各个十二维坐标互相之间肯定是两两相容的。这是因为，如果两个不同的十二维坐标是由同一个三维坐标派生出来的，这就说明它们的前段、中段、后段分别取材于同样的三个集合，并且至少有一段取得有所不同；条件 1 保证了单看这一段的话两者是相容的，根据相容性的定义，整个十二维坐标也就是相容的了。</p>
<p>那么，两个不同的三维坐标所派生的十二维坐标，为什么也一定是相容的呢？首先，两个不同的三维坐标当中，肯定有某一个位置上的数相差为 2 ，由条件 3 到 5 可知，这一点会被继承下去；另外，这两个三维坐标当中肯定还有另外一个位置上有不同的元素，由条件 2 可知，这一点会被继承下去。至此，我们就得到了 n = 12 时 Keller 猜想的一个完整的反例。</p>
<p>显然，低维空间中的任何反例，都可以立即变成高维空间中的反例，我们只需要把低维空间中的反例一层一层地搭起来，每一层都和前一层错开一点即可。因此， n = 12 时的 Keller 猜想被推翻了，则 n ≥ 12 时的 Keller 猜想也就全被推翻了。</p>
<p>在同一篇论文中， Jeffrey Lagarias 和 Peter Shor 紧接着构造出了 n = 10 时 Keller 猜想的反例，背后的思想基本相同。 2002 年， John Mackey 给出了一个 n = 8 时的反例。这说明， n ≥ 8 时的 Keller 猜想全是错的。至此， Keller 猜想只剩下了一个遗留问题：当 n = 7 时， Keller 猜想是否成立。这个问题至今仍未解决。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6487/feed</wfw:commentRss>
            <slash:comments>7</slash:comments>
        </item>
        <item>
            <title>UyHiP 趣题：几乎所有数都能分解成若干个 3x · 4y 之和</title>
            <link>http://www.matrix67.com/blog/archives/6481</link>
            <comments>http://www.matrix67.com/blog/archives/6481#comments</comments>
            <pubDate>Mon, 03 Aug 2015 07:12:24 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[数论]]></category>
            <category><![CDATA[证明]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6481</guid>
            <description>
                <![CDATA[下面这个题目来自 2015 年 7 月的 Using your Head is Permitted 。假设集合 S 是由所有形如 3x · 4y 的数构成的，其中 x 和 y 都是非负整数。因而，集合 S 是一个无穷集合，其中最小的几个元素依次为 1, 3, 4, 9, 12, 16, 27, &#8230; 。如果某个正整数 n 能表示成集合 S 中的一个或多个不重复的数之和，我们就说 n 是集合 S 的一个子集和。例如， 23 就是 S 的一个子集和，因为 23 可以表示成 3 + 4 + 16 。然而， 6 就不是 S [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>下面这个题目来自 <a href="http://www.brand.site.co.il/riddles/201507q.html">2015 年 7 月的 Using your Head is Permitted</a> 。假设集合 S 是由所有形如 3<sup>x</sup> · 4<sup>y</sup> 的数构成的，其中 x 和 y 都是非负整数。因而，集合 S 是一个无穷集合，其中最小的几个元素依次为 1, 3, 4, 9, 12, 16, 27, &#8230; 。如果某个正整数 n 能表示成集合 S 中的一个或多个不重复的数之和，我们就说 n 是集合 S 的一个子集和。例如， 23 就是 S 的一个子集和，因为 23 可以表示成 3 + 4 + 16 。然而， 6 就不是 S 的一个子集和。</p>
<p>求证：除了有限多个正整数以外，其他所有的正整数都是集合 S 的子集和。</p>
<p><span id="more-6481"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>首先我们证明，如果 n 是一个大于 9 的正整数，那么在集合 S 中一定存在一个小于 n 但大于 n / 2 的元素。不妨假设集合 S 中不小于 n 的最小元素是 t = 3<sup>a</sup> · 4<sup>b</sup> 。如果 b > 0 的话，那么 3<sup>a + 1</sup> · 4<sup>b &#8211; 1</sup> = (3 / 4) · t > t / 2 ≥ n / 2 就是一个满足要求的数；如果 b = 0 的话，考虑到 t ≥ n > 9 ，因此 a 肯定至少是 3 ，于是 3<sup>a &#8211; 3</sup> · 4<sup>b + 2</sup> = (16 / 27) · t > t / 2 ≥ n / 2 就是一个满足要求的数。</p>
<p>这说明，我们可以从任意一个大于 9 的正整数 n 里减去 S 中的某个介于 n 和 n / 2 的数，所得结果将会小于 n / 2 ；这个过程可以不断地继续下去，每次减去的数都不重复。最后，我们会得到某个小于等于 9 的数。由于 1 、 3 、 4 也都在 S 里（并且这三个数刚才没使用过），因而容易验证，任意一个小于等于 9 的数都可以继续被减到 0 或者 1 。</p>
<p>现在，把集合 S 里的所有数全都乘以 4 ，不妨把由此得到的新的集合记作 4S 。显然，集合 4S 里的数一定都在集合 S 里，并且根据刚才的结论，我们可以从任意一个形如 4n 的正整数出发，不断减去 4S 里的数，使得最后只剩下 0 或者 4 。由于 1 和 3 都不在 4S 里，因此这两个数刚才都没有用过。因而，如果最后剩下了一个 4 ，我们再从中减去 1 和 3 ，就能让它变成 0 了。这说明，一切形如 4n 的正整数都是集合 S 的子集和。</p>
<p>对于形如 4n + 1 的数，我们可以先在它的基础上减去 9 ；对于形如 4n + 2 的数，我们可以先在它的基础上减去 9 和 81 ；对于形如 4n + 3 的数，我们可以先在它的基础上减去 27 。这样一来，这些数也都变成 4 的整倍数了。我们就能像刚才那样，把它们拆成 S 中的元素之和，并且在此过程中不会再用到 9 、 81、 27 等数。这就证明了，所有大于等于 9 + 81 = 90 的正整数都是集合 S 的子集和。</p>
<p>利用计算机不难验证，不能成为子集和的数事实上只有五个，它们是 2 、 6 、 11 、 18 、 54 。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6481/feed</wfw:commentRss>
            <slash:comments>6</slash:comments>
        </item>
        <item>
            <title>WOM 编码与一次写入型存储器的重复使用</title>
            <link>http://www.matrix67.com/blog/archives/6443</link>
            <comments>http://www.matrix67.com/blog/archives/6443#comments</comments>
            <pubDate>Thu, 23 Jul 2015 14:36:15 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[算法]]></category>
            <category><![CDATA[组合数学]]></category>
            <category><![CDATA[证明]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6443</guid>
            <description>
                <![CDATA[计算机历史上，很多存储器的写入操作都是一次性的。 Wikipedia 的 write once read many 词条里提到了两个最经典的例子，一个是大家熟悉的 CD-R 和 DVD-R ，另一个则是更早的打孔卡片和打孔纸带。在介绍后者时，文章里说：“虽然第一次打孔之后，没有孔的区域还能继续打孔，但这么做几乎没有任何实际用处。”因此，打孔卡片和打孔纸带通常也被看成是只能写入一次的存储设备。 事实上真的是这样吗？ 1982 年， Ronald Rivest 和 Adi Shamir 发表了一篇题为《怎样重复使用一次写入型存储器》（How to Reuse a &#8220;Write-Once&#8221; Memory）的论文，提出了一个很有意思的想法。大家有觉得 Ronald Rivest 和 Adi Shamir 这两个人名都很眼熟吗？没错，这两个人之前曾经和 Leonard Adleman 一道，共同建立了 RSA 公钥加密系统。其中， Ronald Rivest 就是 RSA 中的那个 R ， Adi Shamir 就是 RSA 中的那个 S 。 在这篇论文的开头， Ronald Rivest 和 [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>计算机历史上，很多存储器的写入操作都是一次性的。 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Write_once_read_many">write once read many</a> 词条里提到了两个最经典的例子，一个是大家熟悉的 CD-R 和 DVD-R ，另一个则是更早的打孔卡片和打孔纸带。在介绍后者时，文章里说：“虽然第一次打孔之后，没有孔的区域还能继续打孔，但这么做几乎没有任何实际用处。”因此，打孔卡片和打孔纸带通常也被看成是只能写入一次的存储设备。</p>
<p>事实上真的是这样吗？ 1982 年， Ronald Rivest 和 Adi Shamir 发表了一篇题为《怎样重复使用一次写入型存储器》（How to Reuse a &#8220;Write-Once&#8221; Memory）的论文，提出了一个很有意思的想法。大家有觉得 Ronald Rivest 和 Adi Shamir 这两个人名都很眼熟吗？没错，这两个人之前曾经和 Leonard Adleman 一道，共同建立了 RSA 公钥加密系统。其中， Ronald Rivest 就是 RSA 中的那个 R ， Adi Shamir 就是 RSA 中的那个 S 。</p>
<p>在这篇论文的开头， Ronald Rivest 和 Adi Shamir 举了一个非常简单的例子。假设初始时存储器里的所有 bit 全是 0 。存储器的写入操作是单向的，它只能把 0 变成 1 ，却不能把 1 变成 0 。我们可以把存储器里的每 3 个 bit 分为一组，每一组都只表达 2 个 bit 的值，其中 000 和 111 都表示 00 ， 100 和 011 都表示 01 ， 010 和 101 都表示 10 ， 001 和 110 都表示 11 。好了，假设某一天，你想用这 3 个 bit 表示出 01 ，你就可以把这 3 个 bit 从 000 改为 100 ；假设过了几天，你想再用这 3 个 bit 表示出 10 ，你就可以把这 3 个 bit 从 100 改为 101 。事实上，容易验证，对于 {00, 01, 10, 11} 中的任意两个不同的元素 a 、 b ，我们都能找到两个 3 位 01 串，使得前者表示的是 a ，后者表示的是 b ，并且前者能仅仅通过变 0 为 1 而得到后者。因此，每组里的 bit 都能使用两遍，整个存储器也就具备了“写完还能再改一次”的功能。</p>
<p>不可思议的是，两次表达出 {00, 01, 10, 11} 中的元素，其信息量足足有 4 个 bit ，这却只用 3 个 bit 的空间就解决了。这乍看上去似乎有些矛盾，但仔细一想你就会发现，这并没有什么问题。在写第二遍数据的时候，我们会把第一遍数据抹掉，因此总的信息量不能按照 4 个 bit 来算。利用这种技术，我们便能在 300KB 的一次写入型存储器里写入 200 KB 的内容，再把这 200KB 的内容改写成另外 200KB 的内容。这听上去似乎是神乎其神的“黑科技”，然而原理却异常简单。</p>
<p><span id="more-6443"></span>&nbsp;</p>
<p>由于“一次写入型存储器”（write-once memory）的首字母缩写为 WOM ，因此重复多次使用一次写入型存储器的编码方案也就叫做 WOM 编码了。上面展示的编码系统就是一个 WOM 编码，它可以重复 2 次利用 3 个 bit 的空间，每次都能写入 2 个 bit 的数据。 Ronald Rivest 和 Adi Shamir 把这个 WOM 编码扩展为了一系列更大的 WOM 编码，使得我们能重复 2<sup>k &#8211; 2</sup> + 1 次利用 2<sup>k</sup> &#8211; 1 个 bit 的空间，每次都能写入 k 个 bit 的数据。不妨让我们以 k = 5 为例，对此做一个简单的介绍吧。</p>
<p>所以，我们现在要说明的就是，如何重复 9 次利用 31 个 bit 的空间，每次都能写入 5 个 bit 的数据。首先，把这 31 个 bit 的位置分别编号为 00001, 00010, 00011, &#8230;, 11110, 11111 。然后我们规定，一个 31 位 01 串究竟表示哪 5 个 bit ，就看数字 1 的位置编号全都合在一起，各个位置上究竟有奇数个 1 还是偶数个 1 。假设某个 31 位 01 串的第 1 位、第 3 位和第 31 位是 1 ，其余的地方都是 0 。把这 3 个位置的编号列出来，就得到 00001, 00011, 11111 。在这 3 个编号中，左起第 1 位上的数字 1 共有 1 个，左起第 2 位上的数字 1 共有 1 个，左起第 3 位上 1 个，左起第 4 位上 2 个，左起第 5 位上 3 个。其中，左起第 1 、 2 、 3 、 5 位上都是奇数个 1 ，左起第 4 位上共有偶数个 1 。因此，这个 31 位 01 串最终表达的值就是 11101 。</p>
<p>我们将会说明，只要这个 31 位 01 串里还有至少 16 个数字 0 ，我们都能把最多两个 0 改成 1 ，使得整个 31 位 01 串转而表达任意一个我们想要的新的值。不妨假设这个 31 位 01 串当前表达的是 11101 ，而我们现在想让它表达 10110 。显然，如果在这个 31 位 01 串中，编号 01011 对应位置上的是数字 0 ，我们把它改成数字 1 就行了。如果在这个 31 位 01 串中，编号 01011 对应位置上的是数字 1 ，这又该怎么办呢？我们可以按照“同-异-同-异-异”的原则，把除了 01011 以外的 30 个编号分成 15 组：</p>
<table>
<tr>
<td>(00001, 01010)</td>
<td>(00010, 01001)</td>
<td>(00011, 01000)</td>
<td>(00100, 01111)</td>
<td>(00101, 01110)</td>
</tr>
<tr>
<td>(00110, 01101)</td>
<td>(00111, 01100)</td>
<td>(10000, 11011)</td>
<td>(10001, 11010)</td>
<td>(10010, 11001)</td>
</tr>
<tr>
<td>(10011, 11000)</td>
<td>(10100, 11111)</td>
<td>(10101, 11110)</td>
<td>(10110, 11101)</td>
<td>(10111, 11100)</td>
</tr>
</table>
<p>于是，每一组里的两个编号都满足，左起第 1 位一共有 0 个或 2 个数字 1 ，左起第 2 位一共有恰好 1 个数字 1 ，左起第 3 位一共有 0 个或 2 个数字 1 ，左起第 4 位一共有恰好 1 个数字 1 ，左起第 5 位一共有恰好 1 个数字 1 。其实， 01011 本来应该和 00000 配对，但 00000 并不在我们的编号范围里。所以， 01011 也就没在上面的列表里出现。</p>
<p>但别忘了，这个 31 位 01 串里至少有 16 个数字 0 。由于编号 01011 所对应的是数字 1 ，因此所有的数字 0 都落在了上面 30 个编号上，其中必然会有两个数字 0 落到了同一组里。把这两个 0 都改成 1 ，整个 31 位 01 串所表达的值就能从 11101 变为 10110 了。</p>
<p>初始时，这个 31 位 01 串为 000&#8230;00 。只要里面还有至少 16 个数字 0 ，我们就可以对数据进行改写。第一次改写显然只需要把一个 0 变成 1 即可，今后的每次改写也最多只会把两个 0 变成 1 。因此，这个 31 位 01 串可以被我们重复使用 9 次。根据同样的道理，一个 2<sup>k</sup> &#8211; 1 位 01 串就能被我们重复使用 2<sup>k &#8211; 2</sup> + 1 次，每次写入的都是 k 个 bit 的数据。这正是由 Ronald Rivest 和 Adi Shamir 扩展出来的 WOM 编码，它对于一切大于等于 2 的整数 k 都适用。之前那个把 300KB 当两个 200KB 用的“黑科技”，其实不过是 k = 2 时的一个特例罢了。</p>
<p>随着 k 值的增加，这个科技是“越来越黑”呢，还是“越来越不黑”呢？在这类 WOM 编码中，我们可以把每 2<sup>k</sup> &#8211; 1 个 bit 当作 k · (2<sup>k &#8211; 2</sup> + 1) 个 bit 来用，其比值为 k · (2<sup>k &#8211; 2</sup> + 1) / (2<sup>k</sup> &#8211; 1) 。这个比值越高，就代表每个 bit 的利用率越高。当 k = 2 时，这个比值只有 1.333&#8230; ；当 k = 5 时，这个比值为 1.4516&#8230; ；当 k = 10 时，这个比值增加到了 2.51222&#8230; 。可见，这个科技是“越来越黑”的。事实上，我们有 (2<sup>k &#8211; 2</sup> + 1) / (2<sup>k</sup> &#8211; 1) > 2<sup>k &#8211; 2</sup> / 2<sup>k</sup> = 1 / 4 ，因此不管 k 是多少，整个比值都大于 k / 4 了。这立即证明了，在 WOM 编码中，单个 bit 的利用率可以达到任意大。</p>
<p>&nbsp;</p>
<p>不过， k / 4 虽然成为了一个下界，但同时也成为了一个“槛”。当 k = 20 时，单个 bit 的利用率为 5.00002384&#8230; ；当 k = 50 时，单个 bit 的利用率为 12.5000000000000555&#8230; 。随着 k 的增加，单个 bit 的利用率最终稳定在了 k / 4 的水平。单个 bit 的利用率能超越 k / 4 的水平吗？能！</p>
<p>我们可以让每个编号下都有多个 bit 。例如，我们干脆用 3100 个 bit 的存储空间来表示 5 个 bit 的值，其中前 100 位的编号都是 00001 ，下 100 位的编号都是 00010 ，等等。为了确定出这个 3100 位 01 串究竟表达了哪 5 个 bit 的值，我们就要先找出哪些编号所对应的 100 位 01 串里含有奇数个数字 1 ，再把这些编号全都合在一起，看看各个位置上究竟有奇数个 1 还是偶数个 1 。编码过程也就变得更简单了。刚开始，这个 3100 位 01 串全是 0 ，代表的值也就是 00000 。如果你想写入数据 00010 ，即对左起第 4 位取反，你就把编号为 00010 的那 100 个 bit 中的其中一个 0 改成 1 ；如果你想把它改写成 01101 ，即对左起第 2 位、第 3 位、第 4 位、第 5 位都取反，你就把编号为 01111 的那 100 个 bit 中的其中一个 0 改成 1 ；如果你想再把它改写成 01111 ，即再次对左起第 4 位取反，你就从编号为 00010 的那 100 个 bit 中再选一个 0 ，并把它改成 1 ……但是，这种新的 WOM 编码方案没什么实质性的意义，重复写入次数成倍增加了的同时，所用的存储空间也成倍增加了，单个 bit 的利用率仍然没有提高。这里面有个原因：频繁用到某个编号，对应的数字 0 将会很快用光。为了解决这个问题，我们再出奇招：允许用户根据需要给某个编号里再“充”一些的 0 。把这些想法结合起来，我们就得到了一类更加“黑”的“表格式 WOM 编码”。</p>
<p>我们列一个大表格，表格里一共有 100 行，每一行都是 105 个 bit ，其中前 5 个 bit 表示编号，后 100 个 bit 则用于标记这个编号是否被选中，有奇数个数字 1 代表该编号要选，有偶数个数字 1 代表该编号不选。所有选中的编号里，各个位置上究竟有奇数个 1 还是偶数个 1 ，就决定了这 10500 个 bit 的存储空间究竟表达了哪 5 个 bit 的值。每次改写本质上都是选中某个没选中的编号，或者取消掉某个选中了的编号。如果这个编号所在的行里还有空余的 0 ，我们只需要把其中一个 0 改成 1 即可；如果这个编号所在的行都满了，或者整个表格里根本还没出现这个编号（比如初始时），我们就把新的一行的前 5 个 bit 设为这个编号，再把它后面的某个 0 改成 1 。注意到，所有可能的编号也就只有 00001, 00010, &#8230;, 11111 共 31 种，并且每种编号都是用满一行才会再开一行。这说明，我们每次都能顺利完成改写操作，直到表格中没填满的行不足 31 行为止。在此之前，我们已经成功改写了 (100 &#8211; 31) × 100 = 6900 次。总共 10500 个 bit 的存储空间，竟能 6900 次写入 5 个 bit 的数据，可见单个 bit 的利用率为 5 × 6900 / 10500 = 3.2857&#8230; 。</p>
<p>进一步增加行数和列数，可以进一步增加单个 bit 的利用率。如果整个表格一共有 r 行，每一行里都有 5 + s 个 bit ，我们就能重复使用至少 (r &#8211; 31) · s 次，每次都能写入 5 个 bit 的数据。因此，单个 bit 的利用率就是 5 · (r &#8211; 31) · s  / (r · (5 + s)) 。当 r 和 s 足够大时， (r &#8211; 31) / r 会非常接近 1 ， s / (5 + s) 也会非常接近 1 ，因而整个分数就会非常接近 5 。类似地，如果把 5 换成更大的 k ，单个 bit 的利用率也就能跟着上升为 k ，这优于之前的那个 k / 4 。</p>
<p>&nbsp;</p>
<p>但是，如此高的 bit 利用率，是由极其庞大的存储空间以及极其庞大的重写次数来支撑的，这很难有什么实际用途。在生活中，我们可能更关心的是：为了写入 t 次数据，每次数据量都是 k 个 bit ，至少需要几个 bit 的空间？这个问题分析起来就非常困难了。不妨让我们先从一些最简单的情形出发，一点一点开始探究。为了重复 2 次写入 2 个 bit 的数据，我们可以只用 3 个 bit 的空间（即本文最开始讲到的 WOM 编码）；那么，同样是每次写入 2 个 bit 的数据，为了把写入次数从 2 次提升到 3 次，我们需要几个 bit 的空间呢？我们先给出一个下界： 4 个 bit 的空间是不够的。事实上，我们将会证明，当 t ≥ 3 时，要想重复 t 次写入 2 个 bit 的数据，只用 t + 1 个 bit 的空间是办不到的。</p>
<p>首次写入的数据有 00 、 01 、 10 、 11 共四种可能，初始时的 01 串 000&#8230;00 最多只能表达其中一种可能，其他情况下我们都必须要往存储器里写数字 1 。不妨假设首次写入数据 a 和数据 b 时，我们必须要往存储器里写数字 1 ，其中 a 和 b 是 {00, 01, 10, 11} 中的两个不同的元素。在这段文字和下段文字中，我们假设，首次写入的总是 a 和 b 之一。那么，下一步改写时写入的有可能是什么呢？首次写入 a 后，接下来我们可以把它改写成 b 、 c 、 d ；首次写入 b 后，接下来我们可以把它改写成 a 、 c 、 d 。这里， c 、 d 是 {00, 01, 10, 11} 中的另外两个不同的元素。这意味着，下一步改写时写什么都有可能。容易看出，今后每次改写时更是写什么的都有了。由于每次改写都会把至少一个 0 改成 1 ，因此这就说明了，不管第 t &#8211; 1 次写入的是 {00, 01, 10, 11} 中的哪个元素，存储器里都有至少 t &#8211; 1 个 1 。</p>
<p>为了给最后一次改写留下足够的空间，此时存储器里还得有至少两个 0 。如果存储器一共只有 t + 1 个 bit 的空间的话，你会发现这一切都抵得非常死：不管第 t &#8211; 1 次写入的是什么，存储器里都只能有恰好 t &#8211; 1 个 1 ，并且在最后一次改写时，把其中一个 0 改成 1 ，把另外一个 0 改成 1 ，以及把剩下的两个 0 都改成 1 ，必须正好对应三种可能的改写值。这说明，如果第 t &#8211; 1 次写入的是 a ，把剩下的两个 0 都改成 1 就会得到一个与 a 不同的值；如果第 t &#8211; 1 次写入的是 b ，把剩下的两个 0 都改成 1 就会得到一个与 b 不同的值；对于 c 和 d 也是同理。因而，当存储器里写满了 1 时，它所表达的值既不能是 a ，也不能是 b ，也不能是 c 和 d 。这个矛盾就表明，存储器里只有 t + 1 个 bit 的空间的话是不够的。</p>
<p>别忘了我们正在探究的问题：同样是每次写入 2 个 bit 的数据，为了把写入次数从 2 次提升到 3 次，我们需要几个 bit 的空间？现在我们知道了， 4 个 bit 的空间是不够的。那么， 5 个 bit 的空间够不够呢？答案是肯定的。我们可以把这 5 个 bit 分成两部分，前面一部分有 2 个 bit ，后面一部分有 3 个 bit 。注意到，利用 2 个 bit 的空间可以写入 1 次 2 个 bit 的数据，利用 3 个 bit 的空间可以写入 2 次 2 个 bit 的数据，按照下面给出的方法把两者结合起来，我们就能利用 5 个 bit 的空间写入 1 + 2 = 3 次数据了。下面，我们将会说明，假设每次所写的数据量都相同，如果重写 t<sub>1</sub> 次可以用 r 个 bit 的空间办到，重写 t<sub>2</sub> 次可以用 s 个 bit 的空间办到，那么重写 t<sub>1</sub> + t<sub>2</sub> 次一定可以用 r + s 个 bit 的空间办到。</p>
<p>这看起来似乎非常简单：把 r 个 bit 和 s 个 bit 并排放置，先在前 r 个 bit 里使用前一种子编码系统，把 t<sub>1</sub> 次重写用光了之后，再在后 s 个 bit 里使用后一种子编码系统，直到把 t<sub>2</sub> 次重写用光。解码时，我们就视情况只看前 r 个 bit 或者只看后 s 个 bit ：如果后 s 个 bit 为空，则解码结果完全以前 r 个 bit 为准；如果后 s 个 bit 里有东西，则解码结果完全以后 s 个 bit 为准。太简单了，不是吗？只可惜，这个办法有个问题。如果在后一种子编码系统中， 000&#8230;00 正好对应了某个值（正如本文最开始讲到的 WOM 编码一样， 000 表示 00 ），那么首次往后 s 个 bit 里写数据时就有可能让后 s 个 bit 仍然为空，解码也就出错了。当然，我们可以额外用一个 bit ，专门用来表示刚才是在哪边写的数据。但是，这样我们就用了 r + s + 1 个 bit 的空间了。</p>
<p>那怎么办呢？之前那些奇数个 1 偶数个 1 之类的思路，现在就又派上用场了。我们仍然像刚才那样，前 t<sub>1</sub> 次都在前 r 个 bit 里写，后 t<sub>2</sub> 次都在后 s 个 bit 里写，但解码的方法有所变化：假设前 r 个 bit 表示的值为 a ，假设后 s 个 bit 表示的值为 b ，那么所有 r + s 个 bit 表示什么值，就看 a 和 b 的各个位置上的数字 1 的总数的奇偶性。举个例子吧：假如在前一个子编码系统中， 1101 表示的值是 10 ；假设在后一个子编码系统中， 001 表示的值是 11 ；由于 10 和 11 的左起第 1 位上一共有偶数个 1 ，左起第 2 位上一共有奇数个 1 ，因此在整个编码系统中， 1101001 就表示 01 。在编码时，不管是往哪边写东西，我们都只消写入要表达的值和另一边当前表达出的值在哪些位置上有差即可。</p>
<p>由于仅写 1 次 2 个 bit 的数据只需要 2 个 bit 的空间，重复 2 次写入 2 个 bit 的数据只需要 3 个 bit 的空间，因此重复 3 次写入 2 个 bit 的数据就只需要 2 + 3 = 5 个 bit 的空间了。</p>
<p>我们还可以把这种“合成式编码”继续用于 t 值更大的情况。重复 4 次写入 2 个 bit 的数据需要多少个 bit 的空间呢？我们可以把这 4 次拆成 1 次加上 3 次，也可以把这 4 次拆成 2 次加上 2 次，从而得到两种不同的 WOM 编码。前一种需要 2 + 5 = 7 个 bit 的空间，后一种需要 3 + 3 = 6 个 bit 的空间，因而后者更优。类似地，重复 5 次写入 2 个 bit 的数据可以用 2 + 6 = 8 个 bit 的空间办到，也可以用 3 + 5 = 8 个 bit 的空间办到，两者的效果相同。</p>
<p>我们来总结一下目前的发现。不妨用 f(t) 来表示，为了重复 t 次写入 2 个 bit 的数据，目前已知的最优方案用了多少 bit 的空间。当 t = 1, 2, 3, 4, 5 时， f(t) 的值分别为：</p>
<table>
<tr>
<td>t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>f(t)</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
</tr>
</table>
<p>仅写 1 次 2 个 bit 的数据，显然 1 个 bit 的空间是不够的，我们至少要用 2 个 bit 的空间。为了重复 2 次写入 2 个 bit 的数据，显然 2 个 bit 的空间是不够的，我们至少要用 3 个 bit 的空间。回想我们之前证明过的结论：当 t ≥ 3 时，要想重复 t 次写入 2 个 bit 的数据，只用 t + 1 个 bit 的空间是办不到的，我们至少需要 t + 2 个 bit 的空间。不妨用 g(t) 来表示，为了重复 t 次写入 2 个 bit 的数据，目前已知的理论最少所需空间是多少 bit 。当 t = 1, 2, 3, 4, 5 时， g(t) 的值分别为：</p>
<table>
<tr>
<td>t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>g(t)</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</table>
<p>容易看出，当 t = 1, 2, 3, 4 时，上界与下界是一致的，对应的最优化问题也就有了圆满的回答。但是， t = 5 时的情形就不尽人意了：我们有了一种只使用 8 个 bit 的方案，但只证明了 7 个 bit 是必需的。那么，究竟是我们给出的方案还不够好，还是我们证明的结论还不够强呢？</p>
<p>&nbsp;</p>
<p>Ronald Rivest 和 Adi Shamir 给出了 t = 5 时的一种只需要 7 个 bit 的编码方案，从而把 t = 5 时的情形也完美地解决了。</p>
<p>为了说明这种新的编码是怎么工作的，我们不妨先讲一下它的解码过程。我们把这 7 个 bit 看作一个 7 位 01 串，假设它是 abcdefg 。如果这个 01 串中，数字 1 的个数小于等于 4 ，则按照下述过程确定整个 01 串所表达的值。</p>
<ul>
<li>初始值为 00 。</li>
<li>如果 ab 为 10 ，则左边那一位取反。</li>
<li>如果 ab 为 11 ，并且 cd 或 ef 之一为 01 ，则左边那一位取反。</li>
<li>如果 cd 为 10 ，则右边那一位取反。</li>
<li>如果 cd 为 11 ，并且 ab 或 ef 之一为 01 ，则右边那一位取反。</li>
<li>如果 ef 为 10 ，则左右两位都取反。</li>
<li>如果 ef 为 11 ，并且 ab 或 cd 之一为 01 ，则左右两位都取反。</li>
</ul>
<p>如果数字 1 的个数大于 4 ，则按照下述过程确定整个 01 串所表达的值。</p>
<ul>
<li>如果 a 、 c 、 e 、 g 中有偶数个 1 ，则左边那一位为 0 。</li>
<li>如果 a 、 c 、 e 、 g 中有奇数个 1 ，则左边那一位为 1 。</li>
<li>如果 b 、 d 、 f 、 g 中有偶数个 1 ，则右边那一位为 0 。</li>
<li>如果 b 、 d 、 f 、 g 中有奇数个 1 ，则右边那一位为 1 。</li>
</ul>
<p>然后我们再来叙述一下，如何利用这个 7 位 01 串， 5 次得出任何我们想要表达的值。首先注意到，最开始 abcdefg = 0000000 所表达的值就是 00 。表达一个新的值，本质上就是对当前的值进行下述三种操作之一：左边那一位取反，右边那一位取反，左右两位都取反。接下来我们就来说明，我们可以连续五次实现任何一种取反操作。</p>
<p>在数字 1 的个数小于等于 4 的时候， ab 、 cd 、 ef 各对应一种取反操作。刚开始， ab 、 cd 、 ef 都为 00 。如果把其中一个 00 变为 10 ，就相当于执行了对应的取反操作；如果再把这个 10 变成 11 ，则相当于第二次执行该取反操作（即消除第一次取反的效果）；如果再把剩下的某个 00 变成 01 ，则相当于第三次执行该取反操作；如果再把这个 01 也变成 11 ，则相当于第四次执行该取反操作（即消除第三次取反的效果）。注意，取反的标记是 10 ，让别人再次取反的标记是 01 ，我们很容易把两者区分开来。另外， ab 、 cd 、 ef 当中一定是先出现 11 再出现 01 ，并且不会出现两个 11 一个 01 的情况（否则数字 1 的个数就超过 4 个了）。这说明， 01 作为一种辅助性的标记，将会恰好只为一个 11 服务，因而使用时不会产生什么连带的影响。</p>
<p>所以，如果前面四次取反操作中，每种操作最多出现两次，我们只需要相应地做某些 00 → 10 或者 00 → 10 → 11 的修改就行了。如果前面四次取反操作全是同一种操作，我们只需要对相应的 00 做 00 → 10 → 11 的修改，再选一个剩下的 00 做 00 → 01 → 11 的修改。如果前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，我们就用 00 → 10 实现那次单独的操作，用 00 → 10 → 11 实现前两次的重复操作，最后一定还剩有一个 00 ，把它变为 01 便能实现第三次的重复操作了。举例来说，假如前面四次取反操作分别是左位取反、两位都取反、左位取反、左位取反，那么我们就把 abcdefg 按照 0000000 → 1000000 → 1000100 → 1100100 → 1101100 的方式修改即可。</p>
<p>不管是哪种情况，前面四次取反操作都各只改变 abcdefg 中的一位。此时， abcdefg 里一共将会有 4 个数字 1 ， abcdef 中还有两位是 0 ，而且 g 一定是 0 。在此基础上，任意改动其中一位，都会让 abcdefg 中数字 1 的个数增加到 5 个或 5 个以上，解码方法就变了：解码结果的左位为 0 ，当且仅当 a 、 c 、 e 、 g 中有偶数个 1 ；解码结果的右位为 0 ，当且仅当 b 、 d 、 f 、 g 中有偶数个 1 。现在，我们需要再把某一个或某一些 0 改成 1 ，让整个 7 位 01 串最后一次表达出任意一个我们想要的值。</p>
<p>假设 abcdef 当中，有一个 0 在 a 、 c 、 e 当中，有一个 0 在 b 、 d 、 f 中。无妨假设 a 和 b 都是 0 。那么，不管现在 a 、 c 、 e 、 g 中数字 1 的个数是奇是偶，也不管现在 b 、 d 、 f 、 g 中数字 1 的个数是奇是偶，把 a 改成 1 就能改变前者的奇偶性，把 b 改成 1 就能改变后者的奇偶性，把 g 改成 1 就能同时改变两者的奇偶性，把 a 、 b 、 g 都改成 1 则能保持两者的奇偶性都不变。</p>
<p>假设 abcdef 当中，两个 0 都在 b 、 d 、 f 当中。无妨假设 b 和 d 都是 0 。那么，不管现在 a 、 c 、 e 、 g 中数字 1 的个数是奇是偶，也不管现在 b 、 d 、 f 、 g 中数字 1 的个数是奇是偶，把 b 和 g 都改成 1 就能改变前者的奇偶性，只把 b 改成 1 就能改变后者的奇偶性，把 g 改成 1 就能同时改变两者的奇偶性，把 b 、 d 都改成 1 则能保持两者的奇偶性都不变。当然，如果两个 0 都在 a 、 c 、 e 当中，处理方法也是类似的（其实，两个 0 都在 a 、 c 、 e 当中，这种情况根本不会出现）。</p>
<p>这套 WOM 编码太完美了，对吗？其实，刚才的编码流程里有一个巨大的漏洞，不知道你发现了没有：万一前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，并且出现了一次的操作是最后才出现的，那该怎么办呢？举例来说，假如前面四次取反操作分别是左位取反、左位取反、左位取反、两位都取反，那么我们应该怎么做呢？我们可以先把 0000000 变为 1000000 ，再把 1000000 变为 1100000 。接下来，我们应该把某个 00 变为 01 。麻烦的地方来了：我们应该把哪个 00 变为 01 呢？当然，你应该把 cd 从 00 变为 01 ，从而为下一步的“两位都取反”留下空间。但是，你事先怎么知道，下一步是“两位都取反”呢？在不知道这一点的情况下，你有可能不小心把 ef 改为 01 ，此时 7 位 01 串变成了 1100010 ；接下来，你会发现发现下一步是“两位都取反”，需要把 ef 改为 10 ，然后就彻底傻眼了。这该怎么办呢？遇到这种情况时， a 、 c 、 e 当中一定有正好一个 1 ， b 、 d 、 f 中一定有正好两个 1 ，并且最后的 g 一定为 0 。我们可以按照下面的指示，把 abcdefg 中的其中两个 0 改为 1 ，从而让整个 7 位 01 串提前进入数字 1 的个数大于 4 的状态，并表达出任何一个我们想要表达的值。</p>
<ul>
<li>如果把 a 、 c 、 e 当中剩下的两个 0 都改成 1 ，整个 7 位 01 串表达的值就是 10 。此时， b 、 d 、 f 当中还有一个 0 ，另外 g 也仍然是 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。</li>
<li>如果把 a 、 c 、 e 当中剩下的某一个 0 改成 1 ，再把 b 、 d 、 f 当中剩下的那个 0 改成 1 ，整个 7 位 01 串表达的值就是 01 。此时， a 、 c 、 e 当中还有一个 0 ，另外 g 也仍然是 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。 </li>
<li>如果把 a 、 c 、 e 当中剩下的某一个 0 改成 1 ，再把 g 从 0 改成 1 ，整个 7 位 01 串表达的值就是 11 。此时，  a 、 c 、 e 当中还有一个 0 ， b 、 d 、 f 当中也还有一个 0 ，利用它们就能再表达一个新的值了。不管你是想要左位取反，还是想要右位取反，还是想要两位都取反，都可以通过把其中一个 0 改成 1 或者把两个 0 都改成 1 来实现。 </li>
<li>如果把 b 、 d 、 f 当中剩下的那个 0 改成 1 ，再把 g 从 0 改成 1 ，整个 7 位 01 串表达的值就是 00 。此时，  a 、 c 、 e 当中还有两个 0 ，其他地方都没有 0 了。这不足以让我们表达出所有可能的新的值。这可怎么办呢？幸运的是，如果前面四次取反操作中，有一种操作出现了三次，另一种操作出现了一次，所得的值不可能是 00 。这意味着，我们根本就不会碰到要表达出 00 的情况，自然也就不会碰到刚才的难题了。</li>
</ul>
<p>&nbsp;</p>
<p>前面这些杂乱无章的内容，已经唰唰唰地用掉了一万多字。如果你能一字一句地读到这里，那我真的很佩服你。刚才讲过的东西太多了，我们有必要整理一下线索。</p>
<p>不妨用符号 k × t / n 来表示每次写入的数据量为 k 个 bit ，总的写入次数为 t ，存储器空间为 n 个 bit 的 WOM 编码（注意到，这个符号作为一个算术表达式，算出来正好等于该 WOM 编码的单个 bit 利用率）。我们最开始给出了一种 2 × 2 / 3 的 WOM 编码，紧接着把它扩展为了一类 k × (2<sup>k &#8211; 2</sup> + 1)  / (2<sup>k</sup> &#8211; 1) 的 WOM 编码，其中 k 是任意大于等于 2 的正整数。随后，我们进一步把它扩展为了一类 k × ((r &#8211; (2<sup>k</sup> &#8211; 1)) · s)  / (r · (k + s)) 的 WOM 编码。但我们旋即指出，这样的扩展虽然会带来更高的空间利用率，却因为过于庞大而难以用于实际。</p>
<p>所以，我们转而开始研究另一类更具实际意义，同时也更加困难的问题。不妨用 w(k, t) 来表示所有可行的 k × t / n 当中最小的 n 。那么，当各种正整数 k 和各种正整数 t 组合在一起时， w(k, t) 的值各是多少呢？首先， 2 × 2 / 3 的可行性说明了 w(2, 2) ≤ 3 。紧接着，我们证明了，当 t ≥ 3 时， w(2, t) ≥ t + 2 。随后，我们构造性地证明了 w(k, t<sub>1</sub> + t<sub>2</sub>) ≤ w(k, t<sub>1</sub>) + w(k, t<sub>2</sub>) 。利用 w(2, 1) ≤ 2 以及 w(2, 2) ≤ 3 ，我们得出了 w(2, 3) ≤ 5, w(2, 4) ≤ 6, w(2, 5) ≤ 8 。另外，我们不加证明地给出了两个显然成立的结论： w(2, 1) ≥ 2 ，以及 w(2, 2) ≥ 3 。综合所有这些信息，我们得到：</p>
<ul>
<li>w(2, 1) = 2</li>
<li>w(2, 2) = 3</li>
<li>w(2, 3) = 5</li>
<li>w(2, 4) = 6</li>
<li>w(2, 5) = 7 或 8</li>
</ul>
<p>最后，我们给出了一种 2 × 5 / 7 的 WOM 编码，从而证明了 w(2, 5) = 7 。</p>
<p>寻找 w(k, t) 的精确值果然不是一件易事。我们费了好大的劲儿，结果不但完全没动 k > 2 的情况，就连 k = 2 的情况也只搞出了 5 个准确值。当然，所有的 w(1, t) 显然都等于 t ，所有的 w(k, 1) 显然都等于 k ，因为它们太平凡了，我们一直没提。除此之外，我们能不能再搞出几个新的准确值来呢？</p>
<p>由于 w(3, 1) = 3 ，这说明，要想写入 1 次 3 个 bit 的数据，存储器里至少需要留有 3 个数字 0 。据此容易得出， w(3, 2) ≥ 5 。这是因为，如果存储器里只有 4 个 bit 的话，为了给第 2 次写入数据留下足够的空间，不管第 1 次写入的是什么，我们都最多只能使用 4 个 0 中的 1 个 0 。然而， C(4, 0) + C(4, 1) = 5 &lt; 2<sup>3</sup> ，这说明，最多只用 4 个 0 中的 1 个 0 ，无法表达出 2<sup>3</sup> 种不同的值。因此， w(3, 2) 至少是 5 。</p>
<p>另一方面，只需要简单地把 k<sub>1</sub> × t / n<sub>1</sub> 和 k<sub>2</sub> × t / n<sub>2</sub> 连接起来使用，我们便能得到 (k<sub>1</sub> + k<sub>2</sub>) × t / (n<sub>1</sub> + n<sub>2</sub>) 。这说明， w(k<sub>1</sub> + k<sub>2</sub>, t) ≤ w(k<sub>1</sub> , t) + w(k<sub>2</sub>, t) 。（注意，这和之前的 w(k, t<sub>1</sub> + t<sub>2</sub>) ≤ w(k, t<sub>1</sub>) + w(k, t<sub>2</sub>) 是两个不同的结论。）由于 w(1, 2) = 2 ， w(2, 2) = 3 ，因而 w(3, 2) ≤ 5 。结合上一段的结论，我们就得到了， w(3, 2) = 5 。</p>
<p>类似地，由于 C(5, 0) + C(5, 1) = 6 &lt; 2<sup>4</sup> ，这说明 w(4, 2) ≥ 6 ；另一方面， w(4, 2) = w(2 + 2, 2) ≤ w(2, 2) + w(2, 2) = 3 + 3 = 6 。因此， w(4, 2) = 6 。</p>
<p>我们还能继续把 w(5, 2) 的准确值给搞出来吗？试试看吧。由于 C(6, 0) + C(6, 1) = 7 &lt; 2<sup>5</sup> ，这说明 w(5, 2) ≥ 7 。事实上，由于 C(7, 0) + C(7, 1) + C(7, 2) = 29 &lt; 2<sup>5</sup> ，这说明 w(5, 2) ≥ 8 。另一方面， w(5, 2) = w(2 + 3, 2) ≤ w(2, 2) + w(3, 2) = 3 + 5 = 8 。因此， w(5, 2) = 8 。</p>
<p>这条路还能走多远？让我们继续。由于 C(8, 0) + C(8, 1) + C(8, 2) = 37 &lt; 2<sup>6</sup> ，这说明 w(6, 2) ≥ 9 。另一方面， w(6, 2) = w(2 + 4, 2) ≤ w(2, 2) + w(4, 2) = 3 + 6 = 9 。因此， w(6, 2) = 9 。</p>
<p>难不成我们能把所有的 w(k, 2) 的准确值都搞出来？由于 w(1, 2) + w(6, 2) = w(2, 2) + w(5, 2) = w(3, 2) + w(4, 2) = 11 ，因此我们只能得出 w(7, 2) ≤ 11 。要是 C(10, 0) + C(10, 1) + C(10, 2) + C(10, 3) &lt; 2<sup>7</sup> ，我们就能说明 10 个 bit 的空间不够， w(7, 2) 的准确值也就出来了。只可惜， C(10, 0) + C(10, 1) + C(10, 2) + C(10, 3) = 176 > 2<sup>7</sup> 。刚才的那条路到这里就被堵死了。</p>
<p>在《怎样重复使用一次写入型存储器》中， Ronald Rivest 和 Adi Shamir 说道：“对于较小的 k 和 t ，我们能推导出 w(k, t) 的值，如下表所示。我们尚不知道表中空白处的准确值。”</p>
<table>
<tr>
<td>k&nbsp;&nbsp;╲&nbsp;&nbsp;t</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>6</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>8</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>9</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<p>这个表中的每一项的来历，都是我们刚才讲过的。呃……等等……好像并不是这样…… w(3, 3) 是怎么来的？为什么 w(3, 3) = 7 ？好像就只有这一项是怎么来的我们还不太清楚。</p>
<p>我们首先证明 w(3, 3) ≥ 7 。由于 w(3, 2) = 5 ，这说明，要想写入 2 次 3 个 bit 的数据，存储器里至少需要留有 5 个数字 0 。如果存储器里只有 6 个 bit 的话，为了给后 2 次写入数据留下足够的空间，不管第 1 次写入的是什么，我们都最多只能使用 6 个 0 中的 1 个 0 。然而， C(6, 0) + C(6, 1) = 7 &lt; 2<sup>3</sup> ，这说明，最多只用 6 个 0 中的 1 个 0 ，无法表达出 2<sup>3</sup> 种不同的值。因此， w(3, 3) 至少是 7 。</p>
<p>但是，不管使用 w(k<sub>1</sub> + k<sub>2</sub>, t) 的构造法，还是 w(k, t<sub>1</sub> + t<sub>2</sub>) 的构造法，我们都只能得出 w(3, 3) ≤ 8 。怎么办呢？别忘了，之前我们还讲过很多其他 WOM 编码，比如一类 k × (2<sup>k &#8211; 2</sup> + 1) / (2<sup>k</sup> &#8211; 1) 的 WOM 编码。当 k = 3 时，它就成为了一种 3 × 3 / 7 的 WOM 编码。因此，我们有 w(3, 3) ≤ 7 。结合上一段的结论，我们就得到了， w(3, 3) = 7 。 Ronald Rivest 和 Adi Shamir 列出的表格里的所有项，至此就全部解说完毕了。</p>
<p>&nbsp;</p>
<p>显然，对 w(k, t) 的探讨远未就此结束，我们还留下了很多的未解之谜。不仅如此， w(k, t) 这个记号本身也还可以推广，比如 k 甚至不一定是整数。在实际应用中，每次写入的数据量并不总是满满的 k 个 bit 。假如我们想要用打孔卡片或者打孔纸带记录英文句子，那么每次写入的就是 26 个英文字母中的一个，数据量也就是 log<sub>2</sub>26 了。容易证明，为了重复使用 2 次纸带，每次写入的都是 26 个字母之一，只用 6 个 bit 的空间是不够的。 Ronald Rivest 和 Adi Shamir 则给出了一种只用 7 个 bit 的方案。为了方便地表示出编码方案，他们把这 26 字母排成了下面这个表格：</p>
<table>
<tr>
<td>A</td>
<td>H</td>
<td>G</td>
<td>G</td>
<td>F</td>
<td>Y</td>
<td>L</td>
<td>w</td>
<td>E</td>
<td>Z</td>
<td>Y</td>
<td>r</td>
<td>X</td>
<td>f</td>
<td>p</td>
<td>n</td>
<td>D</td>
<td>W</td>
<td>V</td>
<td>z</td>
<td>U</td>
<td>d</td>
<td>j</td>
<td>o</td>
<td>T</td>
<td>w</td>
<td>k</td>
<td>e</td>
<td>l</td>
<td>t</td>
<td>d</td>
<td>u</td>
</tr>
<tr>
<td>C</td>
<td>S</td>
<td>R</td>
<td>c</td>
<td>Q</td>
<td>i</td>
<td>o</td>
<td>z</td>
<td>P</td>
<td>p</td>
<td>i</td>
<td>h</td>
<td>u</td>
<td>e</td>
<td>x</td>
<td>y</td>
<td>O</td>
<td>z</td>
<td>s</td>
<td>j</td>
<td>s</td>
<td>n</td>
<td>i</td>
<td>w</td>
<td>v</td>
<td>c</td>
<td>q</td>
<td>g</td>
<td>f</td>
<td>k</td>
<td>b</td>
<td>m</td>
</tr>
<tr>
<td>B</td>
<td>N</td>
<td>M</td>
<td>z</td>
<td>L</td>
<td>b</td>
<td>g</td>
<td>m</td>
<td>K</td>
<td>u</td>
<td>t</td>
<td>b</td>
<td>n</td>
<td>g</td>
<td>f</td>
<td>w</td>
<td>J</td>
<td>w</td>
<td>r</td>
<td>h</td>
<td>k</td>
<td>v</td>
<td>x</td>
<td>y</td>
<td>m</td>
<td>j</td>
<td>p</td>
<td>s</td>
<td>o</td>
<td>q</td>
<td>c</td>
<td>i</td>
</tr>
<tr>
<td>I</td>
<td>k</td>
<td>m</td>
<td>q</td>
<td>l</td>
<td>c</td>
<td>k</td>
<td>u</td>
<td>w</td>
<td>t</td>
<td>e</td>
<td>o</td>
<td>s</td>
<td>d</td>
<td>j</td>
<td>v</td>
<td>u</td>
<td>d</td>
<td>b</td>
<td>f</td>
<td>g</td>
<td>e</td>
<td>t</td>
<td>p</td>
<td>y</td>
<td>x</td>
<td>n</td>
<td>l</td>
<td>h</td>
<td>r</td>
<td>z</td>
<td>a</td>
</tr>
</table>
<p>这个表格一共有 4 行，每行的编号分别是 00, 01, 10, 11 ；这个表格一共有 32 列，每列的编号分别是 00000, 00001, 00010, &#8230;, 11110, 11111 。每个位置上的字母是什么，则对应的行号与列号相连后，所得的 7 位 01 串就对应哪个字母。其中，大写字母表示第 1 次写入，小写字母表示第 2 次写入。例如， 0011000 表示的就是字母 T ，把它的左起第 1 位、第 2 位、第 5 位改为 1 之后，就能得到 1111100 ，表示的是字母 h 。</p>
<p>WOM 编码是一个很有趣的课题。最后，我们再介绍两种有趣的 WOM 编码，来结束这篇两万字的长文吧。</p>
<p>David Leavitt 给出了一种 log<sub>2</sub>5 × 3 / 5 的 WOM 编码，它可以重复 3 次使用 5 个 bit 的空间，每次写入的都是 5 个符号中的任意一个，其单个 bit 利用率约为 1.393 。不妨把这 5 个符号分别记作 a 、 b 、 c 、 d 、 e 。第 1 次写入时，用 10000 来表示符号 a ；第 2 次写入时，用 01001 和 00110 之一来表示符号 a ；第 3 次写入时，用 01111 、 10110 、 11001 之一来表示符号 a 。其他符号所对应的编码，则是由符号 a 的编码分别向右循环移动 1 位、 2 位、 3 位、 4 位所得。例如， 00110 表示 a ，那么 00011 就表示 b ， 10001 就表示 c ， 11000 就表示 d ， 01100 就表示 e 。对于符号 a 的另外 5 种编码，则也是用这种方法变成其他各个符号的编码。由于 01 串的长度 5 是一个质数，因此循环移动后得到的编码不会发生重复。</p>
<table>
<tr>
<td>&nbsp;</td>
<td>第 1 次写入</td>
<td colspan="2">第 2 次写入</td>
<td colspan="3">第 3 次写入</td>
</tr>
<tr>
<td>a 的编码</td>
<td>10000</td>
<td>01001</td>
<td>00110</td>
<td>01111</td>
<td>10110</td>
<td>11001</td>
</tr>
<tr>
<td>b 的编码</td>
<td>01000</td>
<td>10100</td>
<td>00011</td>
<td>10111</td>
<td>01011</td>
<td>11100</td>
</tr>
<tr>
<td>c 的编码</td>
<td>00100</td>
<td>01010</td>
<td>10001</td>
<td>11011</td>
<td>10101</td>
<td>01110</td>
</tr>
<tr>
<td>d 的编码</td>
<td>00010</td>
<td>00101</td>
<td>11000</td>
<td>11101</td>
<td>11010</td>
<td>00111</td>
</tr>
<tr>
<td>e 的编码</td>
<td>00001</td>
<td>10010</td>
<td>01100</td>
<td>11110</td>
<td>01101</td>
<td>10011</td>
</tr>
</table>
<p>可以验证，如果第 1 次写入的是 a ，第 2 次想把它改写成 b 、 c 、 d 、 e 都是有办法的；如果第 2 次写入的是 a （不管是哪种形式），第 3 次想把它改写成 b 、 c 、 d 、 e 都是有办法的。再考虑到所有的编码都是循环移动生成的，因此符号 a 能被顺利改写，所有符号都能被顺利改写了。</p>
<p>Frans Merkx 给出了一种 log<sub>2</sub>7 × 4 / 7 的 WOM 编码，它可以重复 4 次使用 7 个 bit 的空间，每次写入的都是 7 个符号中的任意一个，其单个 bit 利用率约为 1.604 。不妨把这 7 个符号分别记作 a 、 b 、 c 、 d 、 e 、 f 、 g 。 Frans Merkx 把它们写成了 7 组，每组三个符号：</p>
<table>
<tr>
<td>(a, b, d)</td>
<td>(a, c, g)</td>
<td>(a, e, f)</td>
<td>(b, c, e)</td>
<td>(b, f, g)</td>
<td>(c, d, f)</td>
<td>(d, e, g)</td>
</tr>
</table>
<p>可以验证，每个符号都正好出现在了三个不同的组里，并且对于任意两个符号，都有且仅有一个组同时包含它们。接下来，我们将给大家演示，通过选中越来越多的符号，如何一次又一次地表示新的符号。</p>
<ul>
<li>初始时，所有的符号都没有被选中，因此我们要表示谁就选中谁。</li>
<li>如果我们想表示一个新的符号，我们就选中唯一那个和已选中的符号以及这个新的符号共组的符号。如果我们把上一步已选中的符号记作 x ，把这一步想要表示的新符号记作 u ，那么我们这一步就选中那个唯一和 x 、 u 同组的符号 y 。</li>
<li>如果我们想再表示一个新的符号，又该怎么办呢？如果这个新的符号是 x ，那么我们就选中任意一个包含 y 但不包含 x 的组里的所有符号；如果这个新的符号是 y ，那么我们就选中任意一个包含 x 但不包含 y 的组里的所有符号；如果这个新符号是除了 x 、 y 的其他符号，那么我们就把这个新符号选中，同时选中唯一那个和 x 、 y 共组的符号（即上一步表示的符号）。不管怎么样，我们都选中了四个符号，其中三个符号形成一组，单独出来的符号就是我们要表示的符号。</li>
<li>如果我们想再表示一个新的符号，又该怎么办呢？假设上一步选中的符号是 p 、 q 、 r 、 s ，其中 p 、 q 、 r 是一组， s 是上一步表示的符号。如果我们要表示 p ，就把唯一那个和 p 、 s 同组的符号选中；如果我们要表示 q ，就把唯一那个和 q 、 s 同组的符号选中；如果我们要表示 r ，就把唯一那个和 r 、 s 同组的符号选中；如果我们要表示其他的符号，那这个符号一定没被选中，我们只需把别的符号都选中，只留下这个符号不选即可。</li>
</ul>
<p>这 7 个符号当中，我们究竟选了哪些符号，这可以用 7 个 bit 来表示。例如， 0100100 就表示我们选中了 b 、 e 这两个符号，别的符号都没选。利用上面给出的方法，我们可以重复四次利用这 7 个 bit ，每次都可以表示 a 、 b 、 c 、 d 、 e 、 f 、 g 这 7 个符号当中任意一个与上次所表示的符号不同的符号。解码时，我们只需要看看这 7 个 bit 里有多少个数字 1 。</p>
<ul>
<li>如果只有 1 个数字 1 ，它表示的就是这个数字 1 所对应的符号。</li>
<li>如果有 2 个数字 1 ，它表示的就是唯一与这两个数字 1 所对应的两个符号同组的符号。</li>
<li>如果有 4 个数字 1 ，对应的四个符号中一定有三个同组，剩下的那个符号就是它所表示的符号。</li>
<li>如果有 5 个数字 1 ，对应的五个符号一定形成了两个组，同在这两个组里的符号就是它所表示的符号。</li>
<li>如果有 6 个数字 1 ，它表示的就是唯一那个数字 0 所对应的符号。</li>
</ul>
<p>有一种几何方法可以直观地表示出这 7 个符号之间的关系。这里，每个符号都用一个点表示，同一组符号所对应的点则都在一条线上（中间那个圆也是一条过三点的线）。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201507051.png" alt="" width="300" /></p>
<p>可以验证，每条线上都有三个点，每个点都引出了三条线，并且任意两点之间都有且只有一条线。由于这个结构是射影几何里的经典结构，因此 Frans Merkx 的 WOM 编码也可以看作是射影几何的妙用。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6443/feed</wfw:commentRss>
            <slash:comments>17</slash:comments>
        </item>
        <item>
            <title>IMO2015 趣题：平衡的但无中心的点集</title>
            <link>http://www.matrix67.com/blog/archives/6463</link>
            <comments>http://www.matrix67.com/blog/archives/6463#comments</comments>
            <pubDate>Sun, 19 Jul 2015 03:16:13 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[几何]]></category>
            <category><![CDATA[证明]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6463</guid>
            <description>
                <![CDATA[2015 年 IMO 的第 1 题很有意思。假设 S 是平面上的某个点集。如果对于 S 中的任意两点 A 、 B ，我们都能在 S 中找到一个点 C 满足 AC = BC ，我们就说这个点集 S 是平衡的。如果对于 S 中的任意三点 A 、 B 、 C ，我们都无法在 S 中找到一个点 P 满足 PA = PB = PC ，我们就说这个点集 S 是无中心的。这道题有两个小问。 证明：对于所有大于等于 3 的正整数 n ，都存在一个由 n 个点构成的平衡点集。 对于哪些大于等于 3 的正整数 n [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>2015 年 IMO 的第 1 题很有意思。假设 S 是平面上的某个点集。如果对于 S 中的任意两点 A 、 B ，我们都能在 S 中找到一个点 C 满足 AC = BC ，我们就说这个点集 S 是平衡的。如果对于 S 中的任意三点 A 、 B 、 C ，我们都无法在 S 中找到一个点 P 满足 PA = PB = PC ，我们就说这个点集 S 是无中心的。这道题有两个小问。</p>
<ol>
<li>证明：对于所有大于等于 3 的正整数 n ，都存在一个由 n 个点构成的平衡点集。</li>
<li>对于哪些大于等于 3 的正整数 n ，存在由 n 个点构成的平衡的但无中心的点集？</li>
</ol>
<p><span id="more-6463"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>在第一小问中，如果 n 为奇数，我们只需要在圆周上取 n 个间隔相等的点即可。这 n 个点把圆周分成了 n 段等长的小圆弧。由于 n 为奇数，因此对于任意两点 A 、 B 来说，在优弧 AB 和劣弧 AB 当中，必然是一个包含奇数段小圆弧，一个包含偶数段小圆弧，其中后者上的中点一定也在点集里，不妨把它记作点 C 。由于弧 AC 的长度等于弧 BC ，因此线段 AC 的长度等于线段 BC 。这说明，这 n 个点满足平衡性的要求。</p>
<p>当 n = 4 时，以 O 为圆心作圆，在圆上找出 A 、 B 、 C 三个点，使得 △OAB 、 △OBC 都是等边三角形。容易验证，这四个点是满足要求的。在此基础上，每次再在圆上找两个与点 O 构成等边三角形的点，就能得到 n = 6, 8, 10, 12, &#8230; 时的方案。对于圆周上的任意两点，圆心 O 到它们俩等距；对于圆心和圆周上的任意一点，都有至少一个和它们配对的等边三角形，这个等边三角形的第三个顶点到它们俩等距。因此，如此得到的方案都是满足要求的。</p>
<p>所以，对于任意大于等于 3 的正整数 n ，满足要求的方案都是存在的。</p>
<p>&nbsp;</p>
<p>在第二小问中，若 n 为奇数，那么圆周上的 n 个间隔相等的点即满足要求。我们刚才已经说明了，这样的点集是平衡的。对于圆周上的任意三点来说，到它们距离相等的点都是这个圆的圆心，而圆心并不在点集中，因此这个点集也是无中心的。</p>
<p>接下来，我们将要证明，对于所有的偶数 n = 2k ，满足要求的点集都是不存在的。由于点集满足平衡性，因此对于点集中的任意两个点 A 、 B ，我们都能找到一个与它们等距的点 C 。我们就说，点 C 平衡了 (A, B) 这一对点。显然，任意一个点最多都只能平衡掉 k &#8211; 1 对点，否则被它平衡的点将会有重复，从而不满足无中心的条件。然而，所有可能的点对数量为 2k · (2k &#8211; 1) / 2 = 2 · k<sup>2</sup> &#8211; k ，这里面最多只有 2k · (k &#8211; 1) = 2 · k<sup>2</sup> &#8211; 2 · k 个点对能被平衡掉。这就说明，满足要求的点集是不存在的。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6463/feed</wfw:commentRss>
            <slash:comments>16</slash:comments>
        </item>
        <item>
            <title>趣题：正方形能被画成什么样？</title>
            <link>http://www.matrix67.com/blog/archives/6433</link>
            <comments>http://www.matrix67.com/blog/archives/6433#comments</comments>
            <pubDate>Tue, 23 Jun 2015 14:48:23 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[几何]]></category>
            <category><![CDATA[动画]]></category>
            <category><![CDATA[惊奇数学事实]]></category>
            <category><![CDATA[证明]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6433</guid>
            <description>
                <![CDATA[房间的正中间悬浮着一个正方形的金属框。五位画家看到这般奇迹后，立即拿出纸和笔，把这个金属框的样子画了下来。但是，由于五位画家观察这个金属框的角度不同，它们画出来的结果也互不相同。请问，这五位画家画出来的结果都是对的吗？换句话说，有没有哪一幅图或者哪几幅图根本不可能是一个正方形的透视图？ &#160; &#160; &#160; &#160; &#160; &#160; &#160; 首先，我们简单解释一下透视图背后的数学模型。假设人眼和实物之间有一个矩形的画布。将实物中的任意一点 X0 与人眼相连，都会与画布有一个交点 X ，那么在人眼看来，实物上的 X0 点和画布上的 X 点是完全重合的。我们就说，这个 X 点是 X0 点在画布上的像。把实物中的每一个点在画布上的像都描出来，我们就能得到实物在这块矩形画布上的透视图了。假设实物上有一条线段 A0B0 ，那么人眼、 A0 点、 B0 点就确定了空间当中的一个平面。由于线段 A0B0 上的任意一点与人眼的连线都在这个平面上，因而这条线段的像一定在这个平面与矩形画布的交线上。这说明，任意一条直线在画布上的像仍然是一条直线。 在这个意义下， A 、 B 、 C 、 D 、 E 这五幅图究竟画得对不对呢？我们先来说明，图 D 和图 E 是对的。事实上，我们将会证明，任意一个两组对边都不平行的凸四边形 ABCD 都可以看作是从某个角度观察正方形所得到的透视图。假设这个四边形的对角线 AC 和 BD 交于点 O ，再假设它的两组对边分别交于点 P 和点 Q [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>房间的正中间悬浮着一个正方形的金属框。五位画家看到这般奇迹后，立即拿出纸和笔，把这个金属框的样子画了下来。但是，由于五位画家观察这个金属框的角度不同，它们画出来的结果也互不相同。请问，这五位画家画出来的结果都是对的吗？换句话说，有没有哪一幅图或者哪几幅图根本不可能是一个正方形的透视图？</p>
<p style="text-align: center"><img src="http://www.matrix67.com/blogimage_2015/201506221.png" alt="" width="600" /></p>
<p><span id="more-6433"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>首先，我们简单解释一下透视图背后的数学模型。假设人眼和实物之间有一个矩形的画布。将实物中的任意一点 X<sub>0</sub> 与人眼相连，都会与画布有一个交点 X ，那么在人眼看来，实物上的 X<sub>0</sub> 点和画布上的 X 点是完全重合的。我们就说，这个 X 点是 X<sub>0</sub> 点在画布上的像。把实物中的每一个点在画布上的像都描出来，我们就能得到实物在这块矩形画布上的透视图了。假设实物上有一条线段 A<sub>0</sub>B<sub>0</sub> ，那么人眼、 A<sub>0</sub> 点、 B<sub>0</sub> 点就确定了空间当中的一个平面。由于线段 A<sub>0</sub>B<sub>0</sub> 上的任意一点与人眼的连线都在这个平面上，因而这条线段的像一定在这个平面与矩形画布的交线上。这说明，任意一条直线在画布上的像仍然是一条直线。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201506222.gif" alt="" width="480" /></p>
<p>在这个意义下， A 、 B 、 C 、 D 、 E 这五幅图究竟画得对不对呢？我们先来说明，图 D 和图 E 是对的。事实上，我们将会证明，任意一个两组对边都不平行的凸四边形 ABCD 都可以看作是从某个角度观察正方形所得到的透视图。假设这个四边形的对角线 AC 和 BD 交于点 O ，再假设它的两组对边分别交于点 P 和点 Q ，如下图所示。过点 A 作平行于 PQ 的直线 l ，令 PO 、 QO 、 BD 所在直线分别与直线 l 交于 M 、 N 、 S 。现在，过直线 l 作与四边形 ABCD 所在平面垂直的平面 γ 。分别以 AS 、 MN 为直径，在平面 γ 上作半圆，两个半圆交于点 O<sub>0</sub> 。过 PQ 所在直线也作一个与四边形 ABCD 所在平面垂直的平面 π ，显然平面 π 和平面 γ 平行。反向延长 OO<sub>0</sub> ，与平面 π 交于点 Z 。延长 ZB 、 ZC 、 ZD ，与平面 γ 交于 B<sub>0</sub> 、 C<sub>0</sub> 、 D<sub>0</sub> 。根据刚才讲到的透视图理论，如果人眼在 Z 处观察平面 γ 上的四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> ，得到的就是四边形 ABCD 了。下面我们证明，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 是一个正方形。</p>
<p style="text-align: center"><img src="http://www.matrix67.com/blogimage_2015/201506223.gif" alt="" width="600" /></p>
<p>首先注意到， Z 、 B<sub>0</sub> 、 C<sub>0</sub> 构成了一个平面，且线段 QCB 也在这个平面上。这个平面与 γ 交于 B<sub>0</sub>C<sub>0</sub> ，与 π 交于 ZQ 。然而，平面 γ 和平面 π 是平行的，这就说明 B<sub>0</sub>C<sub>0</sub> 与 ZQ 平行。同理， AD<sub>0</sub> 也与 ZQ 平行。既然 B<sub>0</sub>C<sub>0</sub> 和 AD<sub>0</sub> 都与 ZQ 平行，因此 B<sub>0</sub>C<sub>0</sub> 与 AD<sub>0</sub> 互相之间也是平行的。</p>
<p>类似地，我们可以说明 D<sub>0</sub>C<sub>0</sub> 和 AB<sub>0</sub> 都与 ZP 平行，因此 D<sub>0</sub>C<sub>0</sub> 与 AB<sub>0</sub> 互相之间也是平行的。这说明，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 是一个平行四边形。在透视图中， B 、 O 、 D 在一条直线上， A 、 O 、 C 也在一条直线上；因此，在实物中， B<sub>0</sub> 、 O<sub>0</sub> 、 D<sub>0</sub> 在一条直线上， A 、 O<sub>0</sub> 、 C<sub>0</sub> 也在一条直线上。这意味着， O<sub>0</sub> 是平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的中心。</p>
<p>线段 QON 和 ZOO<sub>0</sub> 确定了一个平面，这个平面与 γ 和 π 分别交于 NO<sub>0</sub> 和 ZQ ，再次结合 γ ∥ π 便可得出， 线段 NO<sub>0</sub> 平行于 ZQ ，从而也就平行于 B<sub>0</sub>C<sub>0</sub> 、 AD<sub>0</sub> 了。同样地，线段 MO<sub>0</sub> 平行于 ZP ，从而也平行于 D<sub>0</sub>C<sub>0</sub> 、 AB<sub>0</sub> 。然而，由于直径所对的圆周角为 90° ，因此 ∠MO<sub>0</sub>N = 90° ，即 NO<sub>0</sub> 与 MO<sub>0</sub> 垂直。这说明平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的两组对边互相之间也是垂直的，进而说明这个平行四边形实际上是一个矩形。</p>
<p>最后注意到，在透视图中， O 、 B 、 S 在一条直线上，因此在实物中， O<sub>0</sub> 、 B<sub>0</sub> 、 S 也在一条直线上。由于直径所对的圆周角为 90° ，因此 ∠AO<sub>0</sub>S = 90° ，即 ∠AO<sub>0</sub>B<sub>0</sub> = 90° 。考虑到 O<sub>0</sub> 是平行四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的中心，因而 ∠AO<sub>0</sub>B<sub>0</sub> = 90° 就意味着这个平行四边形的对角线互相垂直。这说明，这个平行四边形实际上是一个菱形。</p>
<p>把上面两段的结论结合起来，我们便得到了，四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的确是一个正方形。这表明，任何一个两组对边都不平行的凸四边形，比如图 D 和图 E ，都可以看作是某个正方形的透视图。</p>
<p>利用前面的这些技巧，我们很快可以说明，任何一个梯形，比如图 C ，也都可以看作是某个正方形的透视图。事实上，我们几乎可以把刚才的构造原封不动地套用在梯形上，只不过点 B 、点 B<sub>0</sub> 、点 S 重合在了一起，并且点 P 和点 M 跑到了无穷远处。整个构造过程也大大简化了。假设 AD 与 BC 交于点 Q ， AC 与 BD 交于点 O ，延长 QO 与 AB 交于点 N 。过 AB 作与四边形 ABCD 所在平面垂直的平面 γ ，过 Q 作平行平面 π 。此时，以 AS 为直径的半圆也就变成了以 AB 为直径的半圆，以 MN 为直径的半圆也就变成了过点 N 且垂直于 AB 的直线，令两者的交点为 O<sub>0</sub> 。反向延长 OO<sub>0</sub> ，它与 π 的交点便是人眼的位置 Z 。延长 ZC 、 ZD ，分别与平面 γ 交于 C<sub>0</sub> 、 D<sub>0</sub> ，则四边形 ABC<sub>0</sub>D<sub>0</sub> 即为所求。</p>
<p style="text-align: center"><img src="http://www.matrix67.com/blogimage_2015/201506224.gif" alt="" width="600" /></p>
<p>为什么 ABC<sub>0</sub>D<sub>0</sub> 一定是正方形呢？证明方法和刚才几乎完全相同，只不过更简单一些。这里，我们就不重复叙述了。</p>
<p>&nbsp;</p>
<p>现在，我们已经证明了，图 C 、图 D 、图 E 都是正确的透视图。那么，图 A 和图 B 呢？图 A 显然也是正确的透视图。如果把正方形金属框平行地放在画布的一侧，人眼在画布另一侧的任意位置，那么容易看出，这个正方形里的每条线段，包括对角线，都与它在画布上留下的像平行。于是，原正方形的两组对边分别平行，像的两组对边也分别平行；原正方形的邻边是互相垂直的，像的邻边也是互相垂直的；原正方形的对角线是互相垂直的，像的对角线也是互相垂直的。这足以说明，画布上像也是正方形。容易想到，事实上，把任意平面图形搬到一个与之平行的画布上，不管人眼的位置在哪里，所得到的都是这个平面图形的一个相似形。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201506225.gif" alt="" width="480" /></p>
<p>下面我们说明，图 B 不可能是某个正方形的透视图。注意到图 B 的特征：每一组对边经过透视之后都仍然是平行的。我们来看一看，如果实物上的平行线在画布上也是平行的，这意味着什么。</p>
<p>假设 l<sub>0</sub> 、 m<sub>0</sub> 是实物上的两条平行线， Z 是人眼的位置。那么， Z 和 l<sub>0</sub> 确定了一个平面， Z 和 m<sub>0</sub> 也确定了一个平面。不妨把这两个平面分别叫做 α 和 β ，它们的交线为 i 。容易看出， i 与 l<sub>0</sub> 、 m<sub>0</sub> 都平行。再假设 l<sub>0</sub> 、 m<sub>0</sub> 在画布上的像分别是 l 、 m 。容易看出， l 和 m 所在的直线其实就是画布与 α 和 β 的交线，它们的交点也就是画布与 i 的交点。所以，为了让 l 和 m 平行，即为了让 l 和 m 不相交，我们必须保证画布和 i 也不能相交，即画布和 i 平行，即画布和 l<sub>0</sub> 、 m<sub>0</sub> 都平行。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/201506226.gif" alt="" width="480" /></p>
<p>如果正方形的第一组对边经过透视之后仍然是平行的，这就说明画布平行于第一组对边；如果正方形的第二组对边经过透视之后仍然是平行的，这就说明画布平行于第二组对边。可见，此时画布将会平行于整个正方形所在的平面。但是，我们刚才说过，这种情况下，画布上显示的应该是一个正方形。</p>
<p>所以，正方形的透视图要么是一个正方形，要么是一个至少有一组对边不平行的四边形。所以，图 A 、图 C 、图 D 、图 E 都是合法的正方形透视图，图 B 则不是一个正方形的透视图。</p>
<p>&nbsp;</p>
<p>在刚才的文字中，我们避免使用了消失点、消失线等词，但很多地方实际上都触及了这些概念。如果你对这些概念非常熟悉的话，你会发现前面那些神一般的构造其实来得都很自然，而且论证过程也不必如此大费周章。利用一些与仿射变换、射影变换相关的知识，这个问题的解答还可以变得更加简单。这篇文章部分参考了 100 Great Problems of Elementary Mathematics: Their History and Solution 一书中的第 72 题，同时也参考了 Analytic Projective Geometry 一书中的附录 A ，但完整而初等的解答过程则是自己整理出来的，若有问题，还请大家及时指正。</p>
<p>在写这篇文章的时候，我还做了一个消失点的演示动画，用于更直观地展示 Wikipedia 上的<a href="https://commons.wikimedia.org/wiki/File:Vanishing_Point.jpg">这张图</a>的意思，但最后并没有用到。想着觉得有点可惜，因此还是放上来吧。</p>
<p style="text-align: center"><img src="http://www.matrix67.com/blogimage_2015/201506227.gif" alt="" width="600" /></p>
<p>这个动画表明，如果实物上有 l<sub>0</sub>, m<sub>0</sub>, n<sub>0</sub>, &#8230; 等一系列无限长的平行线，那么它们在画布的像 l, m, n, &#8230; 将会交于一点（即使这些平行线之间的间隔很稀疏，即使这些平行线被平移到了人眼侧方很远的位置）。这个点就叫做这些平行线的“消失点”（vanishing point）。这个消失点究竟在哪儿呢？我们很容易把它找出来。过人眼作出与这些平行线都平行的线，它与画布的交点就是消失点。由此可见，如果画布本身就与这些平行线平行，消失点就不存在了。此时，这些平行线在画布上的像不会交于一点，而是依旧呈现出彼此平行的形态。</p>
<p>在描绘机器、建筑等物体时，我们经常会发现，物体上有三组平行线，它们分别与 X 轴、 Y 轴、 Z 轴平行。如果画布所在的平面与 X 轴、 Y 轴、 Z 轴都不平行，那么对于每一组平行线来说，把它们画在画布上并且延长之后，都应该汇聚于一点。这就是美术当中的三点透视原理。如果画布与某条轴平行，那么其中一组平行线的像将会依旧平行，不会形成任何消失点。这种绘画模式就叫做两点透视。如果画布与其中两条轴都平行，那么其中两组平行线的像都将会依旧平行，只剩下一组拥有消失点的平行线。这种绘画模式就叫做一点透视。刚才我们曾让画布与直线 i 平行，这样做的效果就是减去一个消失点，从而把三点透视变为两点透视，或者把两点透视变为一点透视。</p>
<p>消失点还有另一个更加直观的意义：呈现出一条直线是如何消失在无穷远处的。直线 l<sub>0</sub> 在画布上的消失点，其实就是直线 l<sub>0</sub> 的无穷远点在画布上所对的点。类似地，如果实物上有一个无限大的平面，那么它的无穷远处就对应于画布上的一条线。这条线就叫做这个平面的“消失线”（vanishing line）。如果你站在一望无垠的水平地面上，你所看到的地平线就是地面的消失线，它和你的眼睛齐平。地面上的任何一条无限向前延伸的线，在画布上的消失点都位于消失线上。</p>
<p>所以，之前在解释 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 为何是平行四边形的时候，我们完全可以这么说：画布上的直线 PQ 和人眼齐平，这说明它是平面 γ 的消失线。由于四边形 AB<sub>0</sub>C<sub>0</sub>D<sub>0</sub> 的两组对边在画布上的像都汇聚在了消失线上，这说明这个四边形的每一组对边都是平行的，所以它是一个平行四边形。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6433/feed</wfw:commentRss>
            <slash:comments>23</slash:comments>
        </item>
        <item>
            <title>Sierpiński 的初等数论问题</title>
            <link>http://www.matrix67.com/blog/archives/6405</link>
            <comments>http://www.matrix67.com/blog/archives/6405#comments</comments>
            <pubDate>Sat, 30 May 2015 09:46:30 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[惊奇数学事实]]></category>
            <category><![CDATA[数论]]></category>
            <category><![CDATA[证明]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6405</guid>
            <description>
                <![CDATA[波兰数学家 Wacław Sierpiński 对数论有很多研究。在他一生出版的 50 多本书里， 250 Problems of Elementary Number Theory 一书显得格外有趣。这里面不但有各种出人意料的数学事实，还有很多精妙的证明和大胆的构造，让人大呼过瘾。我从中选择了一些问题，在这里和大家一块儿分享。下面的文字没有完全照搬书中的内容，而是做了大量的改动和扩展；若有出错的地方，还请大家指正。个别题目会涉及一些初等数论中的著名定理，它们都可以在这篇文章里找到。 &#160; 找出所有的正整数 n ，使得 n2 + 1 能被 n + 1 整除。 满足要求的解只有一个： n = 1 。原因很简单：如果 n2 + 1 = n(n + 1) &#8211; (n &#8211; 1) 是 n + 1 的整倍数，那么 n &#8211; 1 也必须是 n + 1 的整倍数，这只有一种可能性，即 n [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>波兰数学家 Wacław Sierpiński 对数论有很多研究。在他一生出版的 50 多本书里， 250 Problems of Elementary Number Theory 一书显得格外有趣。这里面不但有各种出人意料的数学事实，还有很多精妙的证明和大胆的构造，让人大呼过瘾。我从中选择了一些问题，在这里和大家一块儿分享。下面的文字没有完全照搬书中的内容，而是做了大量的改动和扩展；若有出错的地方，还请大家指正。个别题目会涉及一些初等数论中的著名定理，它们都可以在<a href="http://www.matrix67.com/blog/archives/5100">这篇文章</a>里找到。</p>
<p><span id="more-6405"></span>&nbsp;</p>
<p><strong>找出所有的正整数 n ，使得 n<sup>2</sup> + 1 能被 n + 1 整除。</strong></p>
<p>满足要求的解只有一个： n = 1 。原因很简单：如果 n<sup>2</sup> + 1 = n(n + 1) &#8211; (n &#8211; 1) 是 n + 1 的整倍数，那么 n &#8211; 1 也必须是 n + 1 的整倍数，这只有一种可能性，即 n &#8211; 1 = 0 。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意大于 6 的偶数 n ，我们都能找到两个质数 p 和 q ，使得 n &#8211; p 和 n &#8211; q 互质。</strong></p>
<p>不管 n 是多少，令 p = 3, q = 5 即可。这样一来， n &#8211; p 和 n &#8211; q 就是两个相邻的奇数，它们必然互质。</p>
<p>&nbsp;</p>
<p><strong>找出所有公差为 100 的等差数列，使得里面的所有项都是质数。</strong></p>
<p>满足要求的等差数列不存在。这是因为，在 p, p + 100, p + 200 这三个数当中，至少有一个数能被 3 整除，因而 p 只能等于 3 。此时， p + 200 = 3 + 200 = 203 = 7 × 29 ，这就说明满足要求的等差数列不存在。</p>
<p>&nbsp;</p>
<p><strong>找出所有这样的质数，它既能表示成两个质数之和，也能表示成两个质数之差。</strong></p>
<p>满足要求的数只有 5 ，它可以表示成 3 + 2 和 7 &#8211; 2 。下面我们证明，这个问题没有别的解了。如果质数 r 能表示成两个质数之和，那么显然 r > 2 ，因而 r 只能是奇数。两个质数之和是一个奇数，则其中一个质数一定是 2 ；两个质数之差是一个奇数，则其中一个质数也一定是 2 。因此， r 只有可能被表示成 p + 2 和 q &#8211; 2 ，其中 p 和 q 都是质数。这说明， p, r, q 是三个连续奇数。三个连续奇数当中，必然有一个能被 3 整除。如果它们都是质数，那么一定有一个数就是 3 。因此， (p, r, q) = (3, 5, 7) 是唯一的可能。</p>
<p>&nbsp;</p>
<p><strong>33 = 3 × 11 ， 34 = 2 × 17 ， 35 = 5 × 7 。它们组成了三个连续的正整数，其中每个数都是两个不同的质数之积。是否存在四个连续的正整数，使得每个数都是两个不同的质数之积？</strong></p>
<p>不存在。任意四个连续的正整数中，一定有一个能被 4 整除，它显然不是两个不同的质数之积。</p>
<p>&nbsp;</p>
<p><strong>证明：方程 xy + x + y = 2<sup>32</sup> 存在正整数解。</strong></p>
<p>原方程相当于 xy + x + y + 1 = 2<sup>32</sup> + 1 ，即 (x + 1) · (y + 1) = 2<sup>2<sup>5</sup></sup> + 1 ，而后者是 n = 5 时的 Fermat 数，众所周知，它是能被分解成两个大于 1 的整数之积的。</p>
<p>&nbsp;</p>
<p><strong>证明：方程 x<sup>2</sup> + y<sup>2</sup> + 1 = z<sup>2</sup> 有无穷多组正整数解。</strong></p>
<p>对于任意正整数 n ， (2n)<sup>2</sup> + (2n<sup>2</sup>)<sup>2</sup> + 1 = (2n<sup>2</sup> + 1)<sup>2</sup> 都成立。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意一个无限小数（不一定是无限循环小数），我们都能找到一个任意长的数字串，使得它会在这个无限小数的小数展开当中出现无穷多次。</strong></p>
<p>令 m 为任意大的正整数。把小数点后的数字每 m 位分成一组，从而得到无穷多个 m 位数字串。由于不同的 m 位数字串只有 10<sup>m</sup> 种，因而必然有一种数字串会出现无穷多次。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意正整数 m ，总存在一个关于 x 和 y 的整系数方程 ax + by = c ，使得方程恰好有 m 个正整数解。</strong></p>
<p>不管 m 是多少，令 c = m + 1 ，则方程 x + y = c 满足要求。这个方程显然有且仅有 m 个解，它们分别是 (1, m), (2, m &#8211; 1), &#8230;, (m, 1) 。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意正整数 m 、 n ，总存在一个关于 x 和 y 的整系数方程 ax + by = c ，使得 x = m, y = n 是方程的唯一正整数解。</strong></p>
<p>令 a 和 b 为两个不同的大于 m + n 的质数，令 c = am + bn ，则方程 ax + by = c 满足要求。为什么呢？不管是 x ≥ m, y > n ，还是 x > m, y ≥ n ，都会使得 ax + by > am + bn = c 。所以，如果方程有不同的正整数解，则要么 x &lt; m ，要么 y &lt; n 。如果 x &lt; m 的话，那么 m &#8211; x 就是一个小于 m 的正整数。注意到 by = c &#8211; ax = am + bn &#8211; ax = a(m &#8211; x) + bn ，其中 by 是 b 的倍数， bn 是 b 的倍数，因而 a(m &#8211; x) 也是 b 的倍数；但 a 和 b 是两个不同的质数，于是 a(m &#8211; x) 是 b 的倍数就意味着 m &#8211; x 是 b 的倍数。但这是不可能的，因为 m &#8211; x &lt; m &lt; b 。用类似的方法可以说明， y &lt; n 也是不可能的。</p>
<p>&nbsp;</p>
<p><strong>给出一个多项式 f(x) ，它可以被分解成两个因式的乘积，但却存在 100 个不同的正整数，使得每一个数代入 f(x) 后，得到的值都是一个质数。</strong></p>
<p>假设 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>100</sub> 是 100 个不同的质数，则多项式</p>
<p class="indent">f(x) = [(x &#8211; p<sub>1</sub>)(x &#8211; p<sub>2</sub>)&#8230;(x &#8211; p<sub>100</sub>) + 1] · x</p>
<p>显然满足要求。当 x 取 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>100</sub> 时， f(x) 的值分别为 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>100</sub> ，它们都是质数。</p>
<p>&nbsp;</p>
<p><strong>如果 f(x) 是一个整系数多项式，那么 f(x) = 0 有整数解，就意味着对于所有的质数 p ， f(x) = 0 (mod p) 也都有整数解。这个命题反过来成立吗？如果某个整系数多项式 f(x) 满足，对于所有的质数 p ， f(x) = 0 (mod p) 都有整数解，那么 f(x) = 0 也一定有整数解吗？这里， f(x) = 0 (mod p) 的意思是，如果只看 f(x) 除以 p 的余数，则在这个意义下它等于 0 。</strong></p>
<p>4x + 2 = 0 显然没有整数解，但对于任意质数 p ，4x + 2 = 0 (mod p) 都有整数解。当 p = 2 时，任何 x 都是一个解；当 p 为其他质数时， p 必然具有 2k + 1 的形式，此时 x = k 即为一个解。</p>
<p>&nbsp;</p>
<p><strong>有人宣称，任意给定一个正整数，如果它不是质数，那么最多改动其中一个数字，就能把它变成质数。这个说法对吗？</strong></p>
<p>这个说法是错误的。 200 不是一个质数。为了让它变成一个质数，你必须要把末位的 0 改成某个奇数。然而， 201, 203, 205, 207, 209 都不是质数。事实上，我们可以证明，像这样的反例有无穷多个，例如所有形如 2310k &#8211; 210 的数都可以用作反例。为了让它变成一个质数，你必须要把末位的 0 改成某个奇数，然而：</p>
<ul>
<li>2310k &#8211; 210 + 1 = 2310k &#8211; 209 = 11 · (210k &#8211; 19)</li>
<li>2310k &#8211; 210 + 3 = 2310k &#8211; 207 = 3 · (770k &#8211; 69)</li>
<li>2310k &#8211; 210 + 5 = 2310k &#8211; 205 = 5 · (462k &#8211; 41)</li>
<li>2310k &#8211; 210 + 7 = 2310k &#8211; 203 = 7 · (330k &#8211; 29)</li>
<li>2310k &#8211; 210 + 9 = 2310k &#8211; 201 = 3 · (770k &#8211; 67)</li>
</ul>
<p>&nbsp;</p>
<p><strong>证明：存在任意大的正整数 x 、 y ，使得 x 不能整除 y ，但 x<sup>x</sup> 能整除 y<sup>y</sup> 。</strong></p>
<p>选取一个任意大的正整数 k ，再选取一个大于 k · 2<sup>k &#8211; 1</sup> 的质数 p 。令 x = 2<sup>k</sup> ，令 y = 2p ，则 x 和 y 满足要求。这是因为只要 k > 1 ，那么 x 显然都不能整除 y ；同时，我们有 x<sup>x</sup> = (2<sup>k</sup>)<sup>2<sup>k</sup></sup> = 2<sup>k · 2<sup>k</sup></sup> ，并且 y<sup>y</sup> = (2p)<sup>2p</sup> = 2<sup>2p</sup> · p<sup>2p</sup> ，由于 2p > k · 2<sup>k</sup> ，因而 x<sup>x</sup> 能够整除 y<sup>y</sup> 。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意正整数 n ，我们都能找到一个适当的正整数 x ，使得序列 x + 1, x<sup>x</sup> + 1, x<sup>x<sup>x</sup></sup> + 1, &#8230; 里的所有数都能被 n 整除。</strong></p>
<p>很简单， x = 2n &#8211; 1 就满足要求。由于 x 是一个奇数，而奇数的奇数次方一定还是奇数，因而序列 x, x<sup>x</sup>, x<sup>x<sup>x</sup></sup>, &#8230; 里的所有数都是奇数。另外再注意到，对于任意一个奇数 m 来说， a<sup>m</sup> + 1 都能被 a + 1 整除。因此，序列 x + 1, x<sup>x</sup> + 1, x<sup>x<sup>x</sup></sup> + 1, &#8230; 里的所有数都能被 2n = x + 1 整除，它们自然也就都能被 n 整除了。</p>
<p>为什么对于任意一个奇数 m 来说， a<sup>m</sup> + 1 都能被 a + 1 整除呢？由于 a = -1 是方程 a<sup>m</sup> + 1 = 0 的一个解，因而多项式 a<sup>m</sup> + 1 一定能被分解成 (a + 1)( &#8230; &#8230; ) 的样子，这就说明了 a<sup>m</sup> + 1 能被 a + 1 整除。在下一题中，我们还会用到这个结论。</p>
<p>类似地，对于任意一个正整数 m 来说， a<sup>m</sup> &#8211; 1 都能被 a &#8211; 1 整除。由于 a = 1 是方程 a<sup>m</sup> &#8211; 1 = 0 的一个解，因而多项式 a<sup>m</sup> &#8211; 1 一定能被分解成 (a &#8211; 1)( &#8230; &#8230; ) 的样子，这就说明了 a<sup>m</sup> &#8211; 1 能被 a &#8211; 1 整除。在再下一题中，我们会用到这个结论。</p>
<p>&nbsp;</p>
<p><strong>证明：存在无穷多个正整数 n ，使得 2<sup>n</sup> + 1 能被 n 整除。</strong></p>
<p>首先， 2<sup>3</sup> + 1 能被 3 整除。另外，如果 2<sup>n</sup> + 1 能被 n 整除，那么 2<sup>2<sup>n</sup> + 1</sup> + 1 一定能被 2<sup>n</sup> + 1 整除。这是为什么呢？不妨假设 2<sup>n</sup> + 1 = n · k 。考虑到 2<sup>n</sup> + 1 是奇数，因而 k 也一定是奇数。根据上题使用过的结论， (2<sup>n</sup>)<sup>k</sup> + 1 就能被 2<sup>n</sup> + 1 整除，即 2<sup>n · k</sup> + 1 = 2<sup>2<sup>n</sup> + 1</sup> + 1 能被 2<sup>n</sup> + 1 整除。综合上面两条便可得到，存在无穷多个满足要求的 n 。</p>
<p>大家可能会想，那么，有多少个正整数 n ，使得 2<sup>n</sup> &#8211; 1 能被 n 整除呢？答案是，只有一个满足要求的解，即 n = 1 。证明比较复杂，这里略去。</p>
<p>&nbsp;</p>
<p><strong>人们已经知道了，质数有无穷多个。一个经典的结论是，相邻质数之间的间隔也可以达到任意大，或者说存在任意长的连续正整数，使得里面的所有数都是合数。例如， n! + 2, n! + 3, &#8230;, n! + n 就是连续 n &#8211; 1 个正整数，由于它们分别能被 2, 3, &#8230;, n 整除，因而它们都是合数。 Mersenne 质数是形如 2<sup>n</sup> &#8211; 1 的质数，例如 3, 7, 31, 127 等等。目前人们还不知道， Mersenne 质数是否有无穷多个。一个有意思的问题是，在所有形如 2<sup>n</sup> &#8211; 1 的数里面，相邻的 Mersenne 质数之间的间隔也能达到任意大吗？换句话说，在数列 1, 3, 7, 15, 31, &#8230; 中，是否存在任意长的连续项，使得里面的所有数都是合数？</strong></p>
<p>我们首先证明，如果 b 能被 a 整除，那么 2<sup>b</sup> &#8211; 1 也一定能被 2<sup>a</sup> &#8211; 1 整除。不妨假设 b = a · k ，于是 2<sup>b</sup> &#8211; 1 = (2<sup>a</sup>)<sup>k</sup> &#8211; 1 ，根据上上题末尾引申的结论，它能被 2<sup>a</sup> &#8211; 1 整除。证明这件事情还有一个有趣的方法。 2<sup>b</sup> &#8211; 1 的二进制表达就是 b 个数字 1 相连， 2<sup>a</sup> &#8211; 1 的二进制表达就是 a 个数字 1 相连，如果 b 能被 a 整除的话，让这两个数在二进制的世界里做除法，显然能够除尽，比如 111111 除以 11 就等于 10101 。</p>
<p>因此， 2<sup>n! + 2</sup> &#8211; 1, 2<sup>n! + 3</sup> &#8211; 1, &#8230;, 2<sup>n! + n</sup> &#8211; 1 分别能被 2<sup>2</sup> &#8211; 1, 2<sup>3</sup> &#8211; 1, &#8230;, 2<sup>n</sup> &#8211; 1 整除，因而在所有形如 2<sup>n</sup> &#8211; 1 的数里面，相邻的 Mersenne 质数之间的间隔能达到任意大。</p>
<p>“存在任意长的并且全是合数的连续正整数”真的是一个很经典的结论，除了可以平行地扩展到其他的场合，其本身也还有很多加强版。下面这个可以算是我所见过的最终极的加强版了。证明：对于任意的正整数 n 和 s ，我们都能找到任意长的连续正整数，使得对于这里面的每一个数来说，它里面都含有至少 n 个不同的质因数，其中的每个质因数都出现了至少 s 次。</p>
<p>下面，我们就来构造一段满足要求的并且长度为 m 的连续正整数，其中 m 是任意大的正整数。假设 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>mn</sub> 是 mn 个不同的质数。令 a<sub>1</sub> 为前 n 个质数的 s 次方之积，即 a<sub>1</sub> = p<sub>1</sub><sup>s</sup> · p<sub>2</sub><sup>s</sup> · &#8230; · p<sub>n</sub><sup>s</sup> 。类似地，令 a<sub>2</sub> 为下 n 个质数的 s 次方之积，令 a<sub>3</sub> 为再下 n 个质数的 s 次方之积，以此类推，一直到令 a<sub>m</sub> 为最后 n 个质数的 s 次方之积。</p>
<p>显然， a<sub>1</sub>, a<sub>2</sub>, &#8230;, a<sub>m</sub> 两两互质。根据中国剩余定理，我们能够找到一个 x ，使得 x 除以 a<sub>1</sub> 余 a<sub>1</sub> &#8211; 1 ，并且 x 除以 a<sub>2</sub> 余 a<sub>2</sub> &#8211; 2 ，等等，一直到 x 除以 a<sub>m</sub> 余 a<sub>m</sub> &#8211; m 。于是， x + 1, x + 2, &#8230;, x + m 分别能被 a<sub>1</sub>, a<sub>2</sub>, &#8230;, a<sub>m</sub> 整除，这 m 个连续正整数就满足要求了。</p>
<p>&nbsp;</p>
<p><strong>证明：存在无穷多组不同的正整数 x 、 y 、 z ，使得 x(x + 1), y(y + 1), z(z + 1) 构成等差数列。</strong></p>
<p>令 y = 5x + 2， z = 7x + 3 ，于是我们有</p>
<ul>
<li>x(x + 1) = x<sup>2</sup> + x</li>
<li>y(y + 1) = 25x<sup>2</sup> + 25x + 6</li>
<li>z(z + 1) = 49x<sup>2</sup> + 49x + 12</li>
</ul>
<p>它们构成了一个公差为 24x<sup>2</sup> + 24x + 6 的等差数列。</p>
<p>有趣的是，如果进一步问，是否能让 x(x + 1), y(y + 1), z(z + 1), w(w + 1) 构成一个等差数列，答案就是否定的了。这个证明比较复杂，这里略去。</p>
<p>&nbsp;</p>
<p><strong>给出一个无限长的递增等差数列，使得里面的所有项都不能表示为两个质数之和。</strong></p>
<p>数列 11, 17, 23, 29, &#8230; 即符合要求。这些数都是形如 6k + 5 的数。如果 6k + 5 = p + q ，考虑到 6k + 5 是一个奇数，因而 p 和 q 必然有一个是偶数。无妨假设 p 是偶数，如果它又是质数的话，那么 p = 2 。于是， q = 6k + 3 将会成为 3 的倍数。</p>
<p>借助这个思路，我们还能构造一个无限长的递增等差数列，使得里面的所有项都既不能表示为两个质数之和，也不能表示为两个质数之差。例如，数列 37, 67, 97, 127, &#8230; 即符合要求。这些数都是形如 30k + 7 的数。如果 30k + 7 = p + q ，考虑到 30k + 7 是一个奇数，因而 p 和 q 必然有一个是偶数。无妨假设 p 是偶数，如果它又是质数的话，那么 p = 2 。于是， q = 30k + 5 将会成为 5 的倍数。类似地，如果 30k + 7 = p &#8211; q ，那么 q 必然等于 2 ，于是 p = 30k + 9 将会成为 3 的倍数。</p>
<p>&nbsp;</p>
<p><strong>给出一个无限长的递增等差数列，使得里面不含任何一个 Fibonacci 数。</strong></p>
<p>数列 4, 12, 20, 28, 36, &#8230; 符合要求。这些数都是除以 8 余 4 的数，而我们一会儿将会看到，任何一个 Fibonacci 数除以 8 都不可能余 4 。为了计算 a + b 除以 8 的余数，我们可以把 a 替换成它除以 8 的余数，把 b 也替换成它除以 8 的余数，再计算两者相加除以 8 的余数即可。例如， 23 除以 8 的余数是 7 ， 67 除以 8 的余数是 3 ，因而 23 + 67 除以 8 的余数就等于 7 + 3 除以 8 的余数，也就是 2 。根据这个原理，我们很容易算出 Fibonacci 数列各项除以 8 的余数：</p>
<p class="indent">1, 1, 2, 3, 5, 0, 5, 5, 2, 7, 1, 0, 1, 1, &#8230;</p>
<p>第 13 项和第 14 项除以 8 的余数又变回了 1 和 1 ，而下一项除以 8 的余数完全取决于前两项除以 8 的余数，因而后面所有 Fibonacci 数除以 8 的余数就会发生循环。这就说明了，一个 Fibonacci 数除以 8 的余数只可能是 0, 1, 2, 3, 5, 7 ，不可能是 4 。因此，由所有除以 8 余 4 的数构成的等差数列里，一定不会含有任何一个 Fibonacci 数。</p>
<p>用类似的方法可以说明，对于所有小于 8 的正整数 m ， Fibonacci 数除以 m 的余数都可以取遍 0, 1, 2, &#8230;, m &#8211; 1 所有的可能。因而，如果一个无限长的递增等差数列不含任何一个 Fibonacci 数，它的公差至少是 8 。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意一个无限长的递增等差数列，我们都能找出任意长的一段连续项，使得它们都是合数。</strong></p>
<p>假设这个等差数列是 a + b, 2a + b, 3a + b, &#8230; 。假设 n 是一个足够大的正整数。任取 n 个大于 a 的质数 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>n</sub> 。容易看出， a, p<sub>1</sub><sup>2</sup>, p<sub>2</sub><sup>2</sup>, &#8230;, p<sub>n</sub><sup>2</sup> 两两互质。根据中国剩余定理，存在一个整数 m ，使得 m 除以 a 的余数为 0， 并且它除以 p<sub>1</sub><sup>2</sup> 的余数为 p<sub>1</sub><sup>2</sup> &#8211; a &#8211; b ，除以 p<sub>2</sub><sup>2</sup> 的余数为 p<sub>2</sub><sup>2</sup> &#8211; 2a &#8211; b ，除以 p<sub>3</sub><sup>2</sup> 的余数为 p<sub>3</sub><sup>2</sup> &#8211; 3a &#8211; b ，以此类推。于是， m + a + b, m + 2a + b, m + 3a + b, &#8230;, m + n · a + b 就是等差数列的连续 n 项，并且由于第 i 项能被 p<sub>i</sub><sup>2</sup> 整除，因而这里面的每一项都是合数。</p>
<p>&nbsp;</p>
<p><strong>证明：存在任意长的递增等差数列，使得里面的任意两项都是互质的。</strong></p>
<p>假设 m 为某个足够大的正整数。于是， m! + 1, 2 · m! + 1, 3 · m! + 1, &#8230;, m · m! + 1 就成为了一个含有 m 项的公差为 m! 的等差数列。这里面的任意两项都是互质的。如果对于某两个不超过 m 的正整数 k 和 l ， k · m! + 1 和 l · m! + 1 都是 d 的倍数（无妨假设 k &lt; l ），那么 l · (k · m! + 1) &#8211; k · (l · m! + 1) = l &#8211; k 也应该是 d 的倍数，这说明 d ≤ l &#8211; k < m ，因而 d 能整除 m! 。但是 d 也能整除 k · m! + 1 ，因而 d = 1 。

&nbsp;

<strong>证明：存在任意长的递增等差数列，使得里面的每一项都是乘方数。这里，“乘方数”的意思是形如 n<sup>k</sup> 的数，其中 n 、 k 都是正整数，且 k > 1 。</strong></p>
<p>假设 p<sub>1</sub>, p<sub>2</sub>, &#8230;, p<sub>s</sub> 是任意 s 个不同的质数。根据中国剩余定理，对于每一个不超过 s 的正整数 t ，我们都能找到一个大整数 a<sub>t</sub> ，使得 a<sub>t</sub> 除以 p<sub>t</sub> 余 p<sub>t</sub> &#8211; 1 ，并且除以其他 s &#8211; 1 个质数都余 0 。现在，令 Q = 1<sup>a<sub>1</sub></sup> · 2<sup>a<sub>2</sub></sup> · &#8230; · s<sup>a<sub>s</sub></sup> ，那么 Q, 2 · Q, 3 · Q, &#8230;, s · Q 就是一个等差数列。我们来证明，这个等差数列满足要求。对于这个等差数列中的任意一项 t · Q ，我们都有 t · Q = 1<sup>a<sub>1</sub></sup> · 2<sup>a<sub>2</sub></sup> · &#8230; · t<sup>a<sub>t</sub> + 1</sup> · &#8230; · s<sup>a<sub>s</sub></sup> ，根据 a<sub>1</sub>, &#8230;, a<sub>s</sub> 的构造方法可知，这里面的每一个指数都是 p<sub>t</sub> 的倍数。因而， t · Q 可以写成某个数的 p<sub>t</sub> 次方。由于 s 的值可以达到任意大，因而满足要求的等差数列也可以达到任意长。</p>
<p>那么，是否存在无限长的递增等差数列，使得里面的每一项都是乘方数呢？这回，答案就是否定的了。我们可以证明，在任何一个无限长的递增等差数列 a + b, 2a + b, 3a + b, &#8230; 中，总存在一个不是乘方数的数。首先，找出一个比 a + b 更大的质数 p 。由于 a 和 p<sup>2</sup> 互质，因此根据中国剩余定理，我们一定能够找到一个数 m ，使得 m 除以 a 余 0 ，并且除以 p<sup>2</sup> 余 1 。令 k = (p &#8211; b) · m / a 。由于 m 除以 a 余 0 ，因此 k 是个整数；由于 p > b ，因此 k 是一个正整数。于是 k · a + b = (p &#8211; b) · m + b = (p &#8211; b) · m &#8211; (p &#8211; b) + p = (p &#8211; b)(m &#8211; 1) + p 。由于 m 除以 p<sup>2</sup> 余 1 ，因而最后这个式子的前一项是 p<sup>2</sup> 的倍数；但最后这个式子的后一项却只是 p 的倍数，因而两者之和能被 p 整除，却不能被 p<sup>2</sup> 整除。这说明，它不能表示成任何一个数的 1 次以上的乘方。</p>
<p>&nbsp;</p>
<p><strong>是否存在四个连续正整数，使得它们都是乘方数？这里，“乘方数”的意思和上题一样，即形如 n<sup>k</sup> 的数，其中 n 、 k 都是正整数，且 k > 1 。</strong></p>
<p>不存在。在任意四个连续正整数中，必然有一个数是形如 4k + 2 的数。这样的数能被 2 整除，却不能被 4 整除，因而永远不可能是一个乘方数。</p>
<p>那么，是否存在三个连续正整数，使得每一个数都是乘方数呢？ 1962 年， A. Mąkowski 证明了，这也是不可能的，不过证明过程就没那么简单了。那么，是否存在两个相邻的正整数，使得它们都是乘方数呢？这次就有了，例如 8 = 2<sup>3</sup>, 9 = 3<sup>2</sup> 。1844 年， Eugène Catalan 猜想，除了 8 和 9 以外，没有别的相邻乘方数了。 2002 年，这个猜想终于被 Preda Mihăilescu 证明。</p>
<p>&nbsp;</p>
<p><strong>31, 331, 3331, 33331 都是质数。难道数列 31, 331, 3331, 33331, &#8230; 中的所有数都是质数吗？其实并不是这样。证明：数列 31, 331, 3331, 33331, &#8230; 中含有无穷多个合数。</strong></p>
<p>数列的通项公式是 (10<sup>n + 1</sup> &#8211; 7) / 3 。容易验证， 10<sup>1</sup>, 10<sup>2</sup>, &#8230;, 10<sup>17</sup> 除以 17 的余数分别是</p>
<p class="indent">10, 15, 14, 4, 6, 9, 5, 16, 7, 2, 3, 13, 11, 8, 12, 1, 10</p>
<p>其中 10<sup>17</sup> 和 10<sup>1</sup> 除以 17 的余数相同，因此再往后， 10 的乘方除以 17 的余数便会开始循环，循环节的长度为 16 。由于 10<sup>9</sup> 除以 17 余 7 ，这就说明所有的 10<sup>16k + 9</sup> 除以 17 都余 7 。因此，所有的 (10<sup>16k + 9</sup> &#8211; 7) / 3 都是 17 的倍数。</p>
<p>事实上， 31, 331, 3331, 33331, 333331, 3333331, 33333331 都是质数，首次出现的合数为 333333331 = 17 × 19607843 ，这正是 k = 0 时 (10<sup>16k + 9</sup> &#8211; 7) / 3 的值。我们自然会问，除了所有的 (10<sup>16k + 9</sup> &#8211; 7) / 3 以外，数列 31, 331, 3331, 33331, &#8230; 当中还有别的合数吗？答案是，确实还有。用和刚才类似的方法可以推出，所有的 (10<sup>18k + 12</sup> &#8211; 7) / 3 都能被 19 整除，例如 (10<sup>12</sup> &#8211; 7) / 3 = 333333333331 = 19 × 83 × 211371803 。其实，数列 31, 331, 3331, 33331, &#8230; 里的质数没那么多。在前 100 项中，只有第 1, 2, 3, 4, 5, 6, 7, 17, 39, 49, 59, 77, 100 项是质数。</p>
<p>&nbsp;</p>
<p><strong>247 的各位数字之和是 13 ，正好 247 也是 13 的倍数。 399 的各位数字之和是 21 ，正好 399 也是 21 的倍数。是否对于任意正整数 s ，我们都能找到一个正整数 N ，使得 N 的各位数字之和为 s ，并且它也正好是 s 的整倍数？</strong></p>
<p>答案是肯定的。把 s 表示成 2<sup>α</sup> · 5<sup>β</sup> · t 的形式，其中 t 里面不再含有因数 2 和 5 。根据 Euler 定理， 10<sup>φ(t)</sup> 除以 t 余 1 。现在，令 N = 10<sup>α + β</sup> · (10<sup>φ(t)</sup> + 10<sup>2 · φ(t)</sup> + &#8230; + 10<sup>s · φ(t)</sup>) ，则 N 就是一个满足要求的数。首先， N 的十进制表达中含有 s 个数字 1 ，其余的数字全是 0 ，因而它的各位数字之和确实是 s 。另外，上式括号里一共有 s 项，其中每一项除以 t 都余 1 ，因此它们的和除以 t 就余 s ；而 s 是 t 的整倍数，除以 t 余 s 也就相当于是除以 t 余 0 了。这说明，上式括号的计算结果是 t 的整倍数。再加上 10<sup>α + β</sup> 显然是 2<sup>α</sup> · 5<sup>β</sup> 的整倍数，于是便得到了 N 是 s 的整倍数。</p>
<p>&nbsp;</p>
<p><strong>证明：当 n 趋于无穷时， 2<sup>n</sup> 的各位数字之和也将随之趋于无穷。</strong></p>
<p>下面这个证明是由 Andrzej Schinzel 给出的。我们先来定义一个数列 a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, &#8230; ，其中 a<sub>0</sub> = 0 ，并且 a<sub>i + 1</sub> 为最小的使得 2<sup>a<sub>i + 1</sub></sup> 大于 10<sup>a<sub>i</sub></sup> 的正整数。在所有 2 的乘方中，最小的比 10<sup>0</sup> 更大的是 2 的 1 次方，因此 a<sub>1</sub> = 1 ；在所有 2 的乘方中，最小的比 10<sup>1</sup> 更大的是 2 的 4 次方，因此 a<sub>2</sub> = 4 ；在所有 2 的乘方中，最小的比 10<sup>4</sup> 更大的是 2 的 14 次方，因此 a<sub>3</sub> = 14 ……容易看出， a<sub>0</sub> &lt; a<sub>1</sub> &lt; a<sub>2</sub> &lt; &#8230; 。</p>
<p>下面我们来证明，如果 n 大于等于某个 a<sub>k</sub> ，那么 2<sup>n</sup> 的右起第 a<sub>k &#8211; 1</sub> + 1 到第 a<sub>k</sub> 位里至少有一个非 0 数字。不妨让我们以 k = 3 为例来说明这一点，你会发现下面的推理过程适用于一切其他的 k 。当 k = 3 时，我们要证明的就是，如果 n ≥ a<sub>3</sub> = 14 ，那么 2<sup>n</sup> 的右起第 a<sub>2</sub> + 1 = 5 位到第 a<sub>3</sub> = 14 位里至少有一个非 0 数字。反证，假设 2<sup>n</sup> 等于 abc0000000000defg ，其中 a 、 b 、 c 、 d 、 e 、 f 、 g 都是一位数字。注意到 2 的任何乘方的个位都不可能是 0 ，这说明 g 肯定不为 0 。由于 2<sup>14</sup> 可以整除 10<sup>14</sup> ，因而 2<sup>14</sup> 可以整除 abc00000000000000 ；由于 n 大于等于 14 ，因而 2<sup>14</sup> 也可以整除 2<sup>n</sup> = abc0000000000defg 。所以， 2<sup>14</sup> 必然能整除 abc0000000000defg &#8211; abc00000000000000 = defg 。虽然 d 、 e 、 f 都可能为 0 ，但我们刚才说过， g 是肯定不为 0 的，因而 defg 是一个最多 4 位的正整数。但是，2<sup>14</sup> 能整除一个最多 4 位的正整数，这是不可能的，因为根据数列 a<sub>i</sub> 的定义， 2<sup>14</sup> > 10<sup>4</sup> ，也就是说 2<sup>14</sup> 至少有 5 位数，它不可能整除一个比自己小的正整数。</p>
<p>所以，如果 n 大于等于某个 a<sub>k</sub> ，那么 2<sup>n</sup> 的右起第 a<sub>k &#8211; 1</sub> + 1 到第 a<sub>k</sub> 位里至少有一个非 0 数字。事实上，如果 n 大于等于某个 a<sub>k</sub> ，那它也大于 a<sub>1</sub>, a<sub>2</sub>, &#8230;, a<sub>k &#8211; 1</sub> ，因而对于所有不超过 k 的正整数 i 来说， 2<sup>n</sup> 的右起第 a<sub>i &#8211; 1</sub> + 1 到第 a<sub>i</sub> 位里都含有至少一个非 0 数字。可见， 2<sup>n</sup> 里至少有 k 个非 0 数字，即它的各位数字之和至少为 k 。这表明，随着 n 的增加， 2<sup>n</sup> 的各位数字之和可以达到任意大。我们的结论也就证到了。</p>
<p>注意， 2<sup>n</sup> 的各位数字之和趋于无穷大，并不意味着 2<sup>n</sup> 的各位数字之和是不断递增的。当 n = 1, 2, .., 20 时， 2<sup>n</sup> 的各位数字之和为</p>
<p class="indent">2, 4, 8, 7, 5, 10, 11, 13, 8, 7, 14, 19, 20, 22, 26, 25, 14, 19, 29, 31</p>
<p>可以看到，下一项比上一项更小的现象时有发生。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意两个不同的正整数 a 、 b ，我们都能找到无穷多个正整数 n ，使得 a + n 和 b + n 互质。</strong></p>
<p>不妨假设 a &lt; b 。令 n = (b &#8211; a)k + 1 &#8211; a 。只要 k 的值足够大， n 都是正整数。现在，假设 a + n 和 b + n 都是 d 的倍数，那么 (b + n) &#8211; (a + n) = b &#8211; a 必然也是 d 的倍数。同时，注意到 a + n = (b &#8211; a)k + 1 是 d 的倍数，因此 1 一定是 d 的倍数，说明 d 只能等于 1 。</p>
<p>大家肯定会进一步追问，那是否对于任意三个不同的正整数 a 、 b 、 c ，我们都能找到无穷多个正整数 n ，使得 a + n 、 b + n 、 c + n 两两互质呢？答案是，这也是能办到的。不过，这个证明比较复杂，我们就略去了。</p>
<p>那么，是否对于任意四个不同的正整数 a 、 b 、 c 、 d ，我们都能找到无穷多个正整数 n ，使得 a + n 、 b + n 、 c + n 、 d + n 两两互质呢？这就不行了。事实上，我们能够找到一组特殊的 (a, b, c, d) ，使得满足要求的 n 一个也没有。比方说 (a, b, c, d) = (1, 2, 3, 4) 。这样一来，如果 n 是奇数，那么 a + n 和 c + n 显然不互质；如果 n 是偶数，那么 b + n 和 d + n 显然不互质。</p>
<p>&nbsp;</p>
<p><strong>证明：任意一个大于 6 的正整数都可以表示成两个互质的数的和。</strong></p>
<p>如果 n 是一个大于 6 的奇数，那么把 n 拆成 2 和 n &#8211; 2 显然符合要求。这是因为， 2 和任何一个奇数都是互质的。接下来，我们分别考虑 n = 4k 和 n = 4k + 2 两种情况。当 n = 4k 时，把 n 拆成 2k &#8211; 1 和 2k + 1 符合要求。这是因为，如果 2k &#8211; 1 和 2k + 1 都是 d 的倍数，则 (2k + 1) &#8211; (2k &#8211; 1) = 2 也是 d 的倍数，但 2k &#8211; 1 和 2k + 1 都是奇数，因而 d = 1 。当 n = 4k + 2 时，把 n 拆成 2k &#8211; 1 和 2k + 3 显然符合要求。这是因为，如果 2k &#8211; 1 和 2k + 3 都是 d 的倍数，那么 (2k + 3) &#8211; (2k &#8211; 1) = 4 也是 d 的倍数，但 2k &#8211; 1 和 2k + 3 都是奇数，因而 d = 1 。</p>
<p>我们可以用类似的分类讨论的方法来证明，任意大于 17 的正整数都可以表示成三个两两互质的数的和。我们把 n 为偶数的情况分为 n = 6k, n = 6k + 2 和 n = 6k + 4 这三类，它们都有自己的拆分方案：</p>
<ul>
<li>6k = 2 + 3 + (6(k &#8211; 1) + 1)</li>
<li>6k + 2 = 3 + 4 + (6(k &#8211; 1) + 1)</li>
<li>6k + 4 = 2 + 3 + (6k &#8211; 1)</li>
</ul>
<p>当 n 为奇数时，我们分 n = 12k + 1, n = 12k + 3, n = 12k + 5, n = 12k + 7, n = 12k + 9, n = 12k + 11 六类情况讨论。</p>
<ul>
<li>12k + 1 = (6(k &#8211; 1) &#8211; 1) + (6(k &#8211; 1) + 5) + 9</li>
<li>12k + 3 = (6k &#8211; 1) + (6k + 1) + 3</li>
<li>12k + 5 = (6k &#8211; 5) + (6k + 1) + 9</li>
<li>12k + 7 = (6k + 5) + (6k &#8211; 1) + 3</li>
<li>12k + 9 = (6k &#8211; 1) + (6k + 1) + 9</li>
<li>12k + 11 = (6(k + 1) &#8211; 5) + (6(k + 1) + 1) + 3</li>
</ul>
<p>题目给出的结论还有一些有趣的推论。例如，我们可以据此证明，若用 p<sub>k</sub> 表示第 k 个质数，则对于任意 k ≥ 3 都有 p<sub>k + 1</sub> + p<sub>k + 2</sub> ≤ p<sub>1</sub> · p<sub>2</sub> · &#8230; · p<sub>k</sub> 。由于 k ≥ 3 ，因而 p<sub>1</sub> · p<sub>2</sub> · &#8230; · p<sub>k</sub> ≥ 2 · 3 · 5 > 6 ，根据题目给出的结论，它可以表示成两个互质的数 a 和 b 之和。 a 和 a + b 的任何一个公约数也一定是 a 和 b 的公约数，但 a 和 b 没有大于 1 的公约数，说明 a 和 a + b 也没有大于 1 的公约数。这说明， a 和 a + b 也是互质的，即 a 和 p<sub>1</sub> · p<sub>2</sub> · &#8230; · p<sub>k</sub> 是互质的。</p>
<p>令 p 为 a 的任意一个质因数，令 q 为 b 的任意一个质因数。由于 a 和 b 互质，它们拥有完全不同的质因数，因此 p ≠ q 。无妨假设 p &lt; q 。由于 a 和 p<sub>1</sub> · p<sub>2</sub> · &#8230; · p<sub>k</sub> 互质，因此 p ≥ p<sub>k + 1</sub> ；由于 p &lt; q ，因此 q ≥ p<sub>k + 2</sub> 。于是，我们有</p>
<p class="indent">p<sub>k + 1</sub> + p<sub>k + 2</sub> ≤ p + q ≤ a + b = p<sub>1</sub> · p<sub>2</sub> · &#8230; · p<sub>k</sub></p>
<p>&nbsp;</p>
<p><strong>证明：存在无穷多个正整数满足，它可以用至少两种不同的方法表示成四个正整数的平方和。</strong></p>
<p>可以验证， (t &#8211; 8)<sup>2</sup> + (t &#8211; 1)<sup>2</sup> + (t + 1)<sup>2</sup> + (t + 8)<sup>2</sup> = (t &#8211; 7)<sup>2</sup> + (t &#8211; 4)<sup>2</sup> + (t + 4)<sup>2</sup> + (t + 7)<sup>2</sup> 恒成立，因而当 t > 8 时，每一个 t 都对应一个满足要求的正整数，结论便证到了。</p>
<p>我们还可以证明，存在无穷多个正整数满足，它可以用至少两种不同的方法表示成四个正整数的<strong>立方</strong>和。可以验证， (t &#8211; 8)<sup>3</sup> + (t &#8211; 1)<sup>3</sup> + (t + 1)<sup>3</sup> + (t + 8)<sup>3</sup> = (t &#8211; 7)<sup>3</sup> + (t &#8211; 4)<sup>3</sup> + (t + 4)<sup>3</sup> + (t + 7)<sup>3</sup> 恒成立，因而当 t > 8 时，每一个 t 都对应一个满足要求的正整数，结论便证到了。</p>
<p>&nbsp;</p>
<p><strong>证明：任意一个整数都可以用无穷多种方法表示成五个整数的立方和。</strong></p>
<p>首先，可以验证， 6t = (t + 1)<sup>3</sup> + (t &#8211; 1)<sup>3</sup> + (-t)<sup>3</sup> + (-t)<sup>3</sup> 。这说明，任何一个 6 的倍数都可以表示成四个立方数之和。</p>
<p>现在，把任意一个整数写成 6k + r 的形式，其中 r 为 0 、 1 、 2 、 3 、 4 、 5 之一。你会发现，对于任意一个整数 n 来说， 6k + r &#8211; (6n + r)<sup>3</sup> 都是 6 的倍数。这是因为</p>
<p class="indent">6k + r &#8211; (6n + r)<sup>3</sup> = 6k + r &#8211; 216 · n<sup>3</sup> &#8211; 108 · n<sup>2</sup> · r &#8211; 18 · n · r<sup>2</sup> &#8211; r<sup>3</sup></p>
<p>这里面除了 r 和 &#8211; r<sup>3</sup> 以外，其他所有项都是 6 的倍数。而 r &#8211; r<sup>3</sup> = &#8211; (r &#8211; 1) · r · (r + 1) 显然也是 6 的倍数—— r &#8211; 1, r, r + 1 相当于三个连续整数，其中至少有一个是 2 的倍数，且必然有一个是 3 的倍数，因而它们的乘积也就是 6 的倍数。</p>
<p>好了，既然 6k + r &#8211; (6n + r)<sup>3</sup> 总是 6 的倍数，那我们就可以把 6k + r 拆成</p>
<p class="indent">(6k + r &#8211; (6n + r)<sup>3</sup>) + (6n + r)<sup>3</sup></p>
<p>其中前者可以表示成四个立方数之和，后者本身就是一个立方数。这样，我们就成功地把 6k + r 表示成了五个立方数之和。每取一个不同的 n 都会得到一种不同的表示方法，因而表示方法也就有无穷多种。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意一个整数 k ，我们都有无穷多种方法把它表示成 ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± &#8230; ± m<sup>2</sup> 的形式。</strong></p>
<p>显然，我们只需要考虑所有的非负整数 k 即可，因为把所有的符号全都反过来，就能把正数 k 的表达方法转换成负数 k 的表达方法。首先我们来证明，任何 k ≥ 0 都有至少一种表示方法。容易验证：</p>
<ul>
<li>0 = 1<sup>2</sup> + 2<sup>2</sup> &#8211; 3<sup>2</sup> + 4<sup>2</sup> &#8211; 5<sup>2</sup> &#8211; 6<sup>2</sup> + 7<sup>2</sup></li>
<li>1 = 1<sup>2</sup></li>
<li>2 = &#8211; 1<sup>2</sup> &#8211; 2<sup>2</sup> &#8211; 3<sup>2</sup> + 4<sup>2</sup></li>
<li>3 = &#8211; 1<sup>2</sup> + 2<sup>2</sup></li>
</ul>
<p>由于对于任意 m 都有</p>
<p class="indent">(m + 1)<sup>2</sup> &#8211; (m + 2)<sup>2</sup> &#8211; (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup> = 4</p>
<p>因而对于任何非负整数 k 的任何一种表达方法 ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± &#8230; ± m<sup>2</sup> ，我们都有</p>
<p class="indent">k + 4 = ± 1<sup>2</sup> ± 2<sup>2</sup> ± 3<sup>2</sup> ± &#8230; ± m<sup>2</sup> + (m + 1)<sup>2</sup> &#8211; (m + 2)<sup>2</sup> &#8211; (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup></p>
<p>这意味着，只要 k 有表达方法， k + 4 就有表达方法。既然 k = 0, 1, 2, 3 时都有表达方法，那么对于一切的非负整数 k ，表达方法也都存在了。</p>
<p>因此，我们也就证明了，对于任意一切整数 k ，表达方法都是存在的。但是，为什么表达方法有无穷多种呢？只需要注意到</p>
<p class="indent">(m + 1)<sup>2</sup> &#8211; (m + 2)<sup>2</sup> &#8211; (m + 3)<sup>2</sup> + (m + 4)<sup>2</sup> &#8211; (m + 5)<sup>2</sup> + (m + 6)<sup>2</sup> + (m + 7)<sup>2</sup> &#8211; (m + 8)<sup>2</sup> = 0</p>
<p>所以我们可以在任何整数 k 的任何一种表达方法后面添加 8 项，然后再添上 8 项，然后再添上 8 项……从而得到无穷多种表达方法。</p>
<p>&nbsp;</p>
<p><strong>证明：除了 (2, 3) 、 (4, 3) 、 (8, 9) 三种情况以外， 2 的某个乘方和 3 的某个乘方不可能成为两个相邻数。</strong></p>
<p>首先考虑 2<sup>m</sup> = 3<sup>n</sup> + 1 的情况。容易看出，随着 n 的增加， 3<sup>n</sup> 除以 8 的余数是按照 1, 3, 1, 3, 1, 3, &#8230; 的规律循环的。因而 3<sup>n</sup> + 1 除以 8 的余数是按照 2, 4, 2, 4, 2, 4, &#8230; 的规律循环的。这说明，不管正整数 n 为多少， 3<sup>n</sup> + 1 都不可能被 8 整除。如果 2<sup>m</sup> = 3<sup>n</sup> + 1 ，则 2<sup>m</sup> 也不能被 8 整除，这说明 m ≤ 2 。检验可知 (m, n) = (2, 1) 是唯一可能的情况。</p>
<p>接下来考虑 2<sup>m</sup> = 3<sup>n</sup> &#8211; 1 的情况。借助之前讨论的结果可以看出， 3<sup>n</sup> &#8211; 1 除以 8 的余数是按照 0, 2, 0, 2, 0, 2, &#8230; 的规律循环的，因而当 n 是奇数时， 3<sup>n</sup> &#8211; 1 不能被 8 整除。如果 2<sup>m</sup> = 3<sup>n</sup> &#8211; 1 ，则 2<sup>m</sup> 也不能被 8 整除，这说明 m ≤ 2 。检验可知 (m, n) = (1, 1) 是唯一可能的情况。那么，如果 n 是偶数呢？刚才的方法就不管用了。不过，我们还有别的招。不妨假设 n = 2k ，于是 2<sup>m</sup> = 3<sup>n</sup> &#8211; 1 = 3<sup>2k</sup> &#8211; 1 = (3<sup>k</sup> &#8211; 1)(3<sup>k</sup> + 1) ，这说明 3<sup>k</sup> &#8211; 1 和 3<sup>k</sup> + 1 都只含因数 2 ，或者说 3<sup>k</sup> &#8211; 1 和 3<sup>k</sup> + 1 都是 2 的整数次幂。这只有一种可能： 3<sup>k</sup> &#8211; 1 = 2 ， 3<sup>k</sup> + 1 = 4 。据此，我们得到了该问题的最后一组解： (m, n) = (3, 2) 。</p>
<p>&nbsp;</p>
<p><strong>证明：在任意三个大于 7 的连续正整数之中，一定有至少一个数，它包含至少两种不同的质因数。</strong></p>
<p>首先，任何一个形如 6k 的数都必然包含至少两种不同的质因数。其次，当 k > 1 时， 6k + 2 和 6k + 3 不可能都只包含一种质因数。这是因为， 6k + 2 是 2 的倍数，如果它只包含一种质因数，则必是 2 的某个乘方； 6k + 3 是 3 的倍数，如果它只包含一种质因数，则必是 3 的某个乘方；但根据上题的结论，除去少数数值很小的情况以外， 2 的某个乘方和 3 的某个乘方都不可能成为两个相邻整数。类似地，当 k ≥ 1 时， 6k + 3 和 6k + 4 也不可能都只包含一种质因数。这是因为，前者必然是 3 的某个乘方，后者必然是 2 的某个乘方，但根据上题的结论，这是不可能的。</p>
<p>然而，在任意三个大于 7 的连续正整数当中，要么包含形如 6k 的数，要么包含形如 6k + 2 和 6k + 3 的两个相邻数（其中 k > 1 ），要么包含形如 6k + 3 和 6k + 4 的两个相邻数（其中 k ≥ 1 ）。所以，这里面至少有一个数，它包含至少两种不同的质因数。</p>
<p>&nbsp;</p>
<p><strong>证明：存在无穷多对不同的正整数 (m, n) ，使得 m 和 n 拥有完全相同的质因数（仅每个质因数的次数可能有所不同），并且 m + 1 和 n + 1 也拥有完全相同的质因数（仅每个质因数的次数可能有所不同）。</strong></p>
<p>对于任意大于 1 的正整数 k ， (m, n) = (2<sup>k</sup> &#8211; 2, 2<sup>k</sup>(2<sup>k</sup> &#8211; 2)) 显然都满足要求。 m 和 n 分解质因数之后的唯一差异就是， n 比 m 多了一堆 2 ，而 2 本来就是两者都已经有了的质因数。另外， m + 1 = 2<sup>k</sup> &#8211; 1 ， n + 1 = 2<sup>k</sup>(2<sup>k</sup> &#8211; 2) + 1 = (2<sup>k</sup> &#8211; 1)<sup>2</sup> ，两者显然也拥有完全相同的质因数。</p>
<p>Paul Erdős 曾问，是否还有别的满足要求的 (m, n) 。答案是肯定的，例如 (75, 1215) 满足要求。 75 = 3 × 5<sup>2</sup> ， 1215 = 3<sup>5</sup> × 5 ； 76 = 2<sup>2</sup> × 19 ， 1216 = 2<sup>6</sup> × 19 。</p>
<p>&nbsp;</p>
<p><strong>找出所有的正整数组 (x, y, z) ，使得分数 x / y 、 y / z 、 z / x 都是最简分数，并且它们的和是一个正整数。</strong></p>
<p>假设 x / y + y / z + z / x = m ，其中 m 是一个正整数。等式可以变为 x<sup>2</sup>z + y<sup>2</sup>x + z<sup>2</sup>y = mxyz 。等号左边的后面两项都是 y 的倍数，等号右边的结果也是 y 的倍数，这说明等号左边的第一项也必然是 y 的倍数。也就是说， x<sup>2</sup>z 是 y 的倍数。类似地， y<sup>2</sup>x 是 z 的倍数， z<sup>2</sup>y 是 x 的倍数。但是，分数 x / y 、 y / z 、 z / x 都是最简分数，这说明 x 、 y 、 z 两两互质，因而 x<sup>2</sup>z 和 y 是互质的， y<sup>2</sup>x 和 z 是互质的， z<sup>2</sup>y 和 x 是互质的。由此可知 y = 1, z = 1, x = 1 ，因而 1 / 1 + 1 / 1 + 1 / 1 = 3 是这个问题的唯一解。</p>
<p>&nbsp;</p>
<p><strong>证明： x / y + y / z + z / x = 1 和 x / y + y / z + z / x = 2 都没有正整数解。</strong></p>
<p>第一个问题很简单。 x / y 、 y / z 和 z / x 的乘积为 1 ，说明三者必有一个大于等于 1 ，因而 x / y + y / z + z / x > 1 。第二个问题则稍微复杂一些。由于任意三个正数的算术平均数一定大于等于它们的几何平均数，因而 (x / y + y / z + z / x) / 3 ≥ ((x / y) · (y / z) · (z / x))<sup>1/3</sup> = 1 ，这说明 x / y + y / z + z / x ≥ 3 。</p>
<p>容易看出， x / y + y / z + z / x = 3 是有正整数解的，例如 x = y = z =  1 。 x / y + y / z + z / x = 5 的其中一组正整数解为 x = 1, y = 2, z = 4 。 x / y + y / z + z / x = 6 的其中一组正整数解为 x = 2, y = 12, z = 9 。如果所涉及的数更大一些，找出相应的解就不太容易了。 Woody Dudley 发现 x / y + y / z + z / x = 41 是有正整数解的，其中一组正整数解为 x = 350, y = 196, z = 5 。究竟对于哪些正整数 n ，方程 x / y + y / z + z / x = n 有正整数解，这是一个非常困难的问题。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意正整数 s ≥ 3 ，方程 1 / x<sub>1</sub> + 1 / x<sub>2</sub> + &#8230; + 1 / x<sub>s</sub> = 1 都有满足 x<sub>1</sub> &lt; x<sub>2</sub> &lt; &#8230; &lt; x<sub>s</sub> 的正整数解，且随着 s 的增加，满足要求的解的数量也随之增加。</strong></p>
<p>当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是一组满足要求的解。另外，如果对于某个 s ≥ 3 ， (x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>s</sub>) 是一组满足要求的解，那么 x<sub>1</sub> 必然大于 1 。于是，我们有 </p>
<p class="indent">&nbsp; 1 / 2 + 1 / (2x<sub>1</sub>) + 1 / (2x<sub>2</sub>) + &#8230; + 1 / (2x<sub>s</sub>)<br />
= 1 / 2 + (1 / 2) · (1 / x<sub>1</sub> + 1 / x<sub>2</sub> + &#8230; + 1 / x<sub>s</sub>)<br />
= 1 / 2 + (1 / 2) · 1<br />
= 1</p>
<p>并且 2 &lt; 2x<sub>1</sub> &lt; 2x<sub>2</sub> &lt; &#8230; &lt; 2x<sub>s</sub> 。它们就成为了 s 增加 1 之后的一组解。这就立即说明了，随着 s 的增加，满足要求的解的个数不会减少，至少会保持不变。但是，我们需要证明的是，随着 s 的增加，满足要求的解的个数会严格增加。怎么办呢？</p>
<p>很简单。如果对于某个 s ≥ 3 ， (x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>s</sub>) 是一组满足要求的解。于是，我们有 </p>
<p class="indent">&nbsp; 1 / 2 + 1 / 3 + 1 / (6x<sub>1</sub>) + 1 / (6x<sub>2</sub>) + &#8230; + 1 / (6x<sub>s</sub>)<br />
= 5 / 6 + (1 / 6) · (1 / x<sub>1</sub> + 1 / x<sub>2</sub> + &#8230; + 1 / x<sub>s</sub>)<br />
= 5 / 6 + (1 / 6) · 1<br />
= 1</p>
<p>并且 2 &lt; 3 &lt; 6x<sub>1</sub> &lt; 6x<sub>2</sub> &lt; &#8230; &lt; 6x<sub>s</sub> 。它们就成为了 s 增加 2 之后的一组解。而且，用这种方法生成的解肯定和用前一种方法生成的解是不同的——前一种方法中，所有的分母都是偶数；但在这里的方法中，第二项的分母是 3 。于是， s = 5 的解数至少等于 s = 4 的解数加上 s = 3 的解数，s = 6 的解数至少等于 s = 5 的解数加上 s = 4 的解数……因而，随着 s 的增加，解的数量一定是严格增加的。</p>
<p>且慢！这只能说明， s = 5 时的解数大于 s = 4 时的解数， s = 6 时的解数大于 s = 5 时的解数，等等，但为什么 s = 4 时的解数大于 s = 3 时的解数呢？这一点是刚才的推理覆盖不到的，我们还需要额外证明一下。</p>
<p>首先我们证明，当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是唯一的一组解。如果 x<sub>1</sub> ≥ 3 ，则 x<sub>2</sub> ≥ 4 ， x<sub>3</sub> ≥ 5 ，于是 1 / x<sub>1</sub> + 1 / x<sub>2</sub> + 1 / x<sub>3</sub> ≤ 1 / 3 + 1 / 4 + 1 / 5 = 47 / 60 &lt; 1 。这说明， x<sub>1</sub> 不能大于等于 3 ，因而只能等于 2 。类似地，由于 1 / 2 + 1 / 4 + 1 / 5 = 19 / 20 &lt; 1 ，这说明 x<sub>2</sub> 不能大于等于 4 ，只能等于 3 。因而，当 s = 3 时， x<sub>1</sub> = 2, x<sub>2</sub> = 3, x<sub>3</sub> = 6 是唯一的一组解。</p>
<p>可以验证，当 s = 4 时，我们至少有以下六组解：</p>
<ul>
<li>1 / 2 + 1 / 3 + 1 / 7 + 1 / 42 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 8 + 1 / 24 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 9 + 1 / 18 = 1</li>
<li>1 / 2 + 1 / 3 + 1 / 10 + 1 / 15 = 1</li>
<li>1 / 2 + 1 / 4 + 1 / 5 + 1 / 20 = 1</li>
<li>1 / 2 + 1 / 4 + 1 / 6 + 1 / 12 = 1</li>
</ul>
<p>因此，当 s 从 3 增加到 4 时，解的数量也是严格增加的。</p>
<p>&nbsp;</p>
<p><strong>证明：对于任意正整数 n ，方程 x<sub>1</sub> + x<sub>2</sub> + &#8230; + x<sub>n</sub> = x<sub>1</sub> · x<sub>2</sub> · &#8230; · x<sub>n</sub> 至少有一组正整数解。</strong></p>
<p>当 n = 1 时，我们有 1 = 1 。当 n = 2 时，我们有 2 + 2 = 2 × 2 。当 n ≥ 3 时， 1 + 1 + &#8230; + 1 + 2 + n = 1 × 1 × &#8230; × 1 × 2 × n 总成立（等号左右两边各有 n &#8211; 2 个 1 ）。</p>
<p>对于某些特定的 n ，有没有可能还有其他的解呢？这里，我们规定 x<sub>1</sub> ≤ x<sub>2</sub> ≤ &#8230; ≤ x<sub>n</sub> ，从而排除掉一些本质相同的解。答案是肯定的。例如，当 n = 5 时，除了 1 + 1 + 1 + 2 + 5 = 1 × 1 × 1 × 2 × 5 以外，我们还有以下两组解：</p>
<ul>
<li>1 + 1 + 1 + 3 + 3 = 1 × 1 × 1 × 3 × 3</li>
<li>1 + 1 + 2 + 2 + 2 = 1 × 1 × 2 × 2 × 2</li>
</ul>
<p>因此，当 n = 5 时，方程一共有至少三组正整数解。可以证明，当 n = 5 时，方程确实也只有这三组正整数解。</p>
<p>当 n = 13 时，将会首次出现有四组解的情况：</p>
<ul>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 13 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 2 × 13</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 3 + 7 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 3 × 7</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 4 + 5 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 4 × 5</li>
<li>1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 3 + 3 = 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 1 × 2 × 3 × 3</li>
</ul>
<p>由此产生了一个有趣的问题：到了 n 足够大的时候，会不会出现有 5 组解、 6 组解甚至 100 组解的情况？答案仍然是肯定的。首先注意到，(2<sup>a</sup> + 1)(2<sup>b</sup> + 1) = 2<sup>a + b</sup> + 2<sup>a</sup> + 2<sup>b</sup> + 1，它应该等于 2<sup>a + b</sup> &#8211; 1 个 1 、一个 2<sup>a</sup> + 1 和一个 2<sup>b</sup> + 1 相加的结果。因此，当 n = 2<sup>200</sup> + 1 时，至少会有这么 100 组解：前面 2<sup>200</sup> &#8211; 1 个数都是 1 ，最后两个数是 2 + 1 和 2<sup>199</sup> + 1 ，或者 2<sup>2</sup> + 1 和 2<sup>198</sup> + 1 ，或者 2<sup>3</sup> + 1 和 2<sup>197</sup> + 1 ，一直到 2<sup>100</sup> + 1 和 2<sup>100</sup> + 1 。利用这种思路，我们总能找到适当的 n ，使得满足要求的解的个数达到任意你想要的数目。</p>
<p>另一方面，不管 n 是多少，解的个数都是有限的。我们可以用一种非常简单的方法证明这一点。考虑到这 n 个数当中最大的那个数是 x<sub>n</sub> ，因而我们有</p>
<p class="indent">x<sub>1</sub> · x<sub>2</sub> · &#8230; · x<sub>n</sub> = x<sub>1</sub> + x<sub>2</sub> + &#8230; + x<sub>n</sub> ≤ n · x<sub>n</sub></p>
<p>这说明 x<sub>1</sub> · x<sub>2</sub> · &#8230; · x<sub>n &#8211; 1</sub> ≤ n ，进而说明 x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>n &#8211; 1</sub> 都不能超过 n 。所以， (x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>n &#8211; 1</sub>) 的取值组合只有有限多种情况。由于每一种情况最多只能对应一个解，因而总的解数就是有限的了。等等，为什么每一种情况最多只能对应一个解呢？假设 x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>n &#8211; 1</sub> 的值已经确定了，不妨设它们的和为 S ，积为 P ，那么 x<sub>n</sub> 就应该满足方程 S + x<sub>n</sub> = P · x<sub>n</sub> ，于是 x<sub>n</sub> 只能等于 S / (P &#8211; 1) 。这是否对应了一个满足要求的解，则取决于 S / (P &#8211; 1) 的值是不是正整数，以及它和 x<sub>n &#8211; 1</sub> 的大小关系。</p>
<p>让我们用 f(n) 来表示 n 个正整数之和等于它们的乘积有多少种不同的情况。我们已经证明了， f(n) 的值可以达到任意大，但却始终是有限的。但是，我们却很难刻画出关于数列 f(n) 的具体特征。 2002 年，经过一番计算机搜索后， Michael Ecker 作出了这么一个猜测：只有有限多个 n 满足 f(n) = 1 ，它们分别是 2, 3, 4, 6, 24, 114, 174, 444 。这个猜想是否正确，至今仍然未知。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6405/feed</wfw:commentRss>
            <slash:comments>23</slash:comments>
        </item>
        <item>
            <title>趣题：不等式背后的直观意义</title>
            <link>http://www.matrix67.com/blog/archives/6386</link>
            <comments>http://www.matrix67.com/blog/archives/6386#comments</comments>
            <pubDate>Sun, 24 May 2015 01:07:22 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[概率]]></category>
            <category><![CDATA[组合数学]]></category>
            <category><![CDATA[证明]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6386</guid>
            <description>
                <![CDATA[有时，为了说明某个式子始终成立，我们会为它构造一个情境。例如，为了说明 C(m, 0) · C(w, r) + C(m, 1) · C(w, r &#8211; 1) + &#8230; + C(m, r) · C(w, 0) = C(m + w, r) 始终成立，只需要注意到，等号的左边和右边计算的都是同一个东西：假如一个班上有 m 个男生 w 个女生，从中选出 r 个人有多少种方案。等号左边的计算方式是，分别计算 0 男 r 女、 1 男 r &#8211; 1 女、 2 男 r &#8211; 2 女等 r + 1 种情况的方案数，然后把它们加起来。等号右边则是直接算出了从这 m [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>有时，为了说明某个式子始终成立，我们会为它构造一个情境。例如，为了说明</p>
<p class="indent">C(m, 0) · C(w, r) + C(m, 1) · C(w, r &#8211; 1) + &#8230; + C(m, r) · C(w, 0) = C(m + w, r)</p>
<p>始终成立，只需要注意到，等号的左边和右边计算的都是同一个东西：假如一个班上有 m 个男生 w 个女生，从中选出 r 个人有多少种方案。等号左边的计算方式是，分别计算 0 男 r 女、 1 男 r &#8211; 1 女、 2 男 r &#8211; 2 女等 r + 1 种情况的方案数，然后把它们加起来。等号右边则是直接算出了从这 m + w 个人中选出 r 个人的方案数。两种算法所得的答案应该是相等的。</p>
<p>现在，请你构造一个情境，来说明不等式</p>
<p class="indent">(1 &#8211; p<sup>m</sup>)<sup>n</sup> + (1 &#8211; q<sup>n</sup>)<sup>m</sup> ≥ 1</p>
<p>总成立，其中 m 、 n 是任意正整数， p 、 q 是任意正实数，并且满足 p + q ≤ 1 。</p>
<p><span id="more-6386"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>假设有一个三角形 ABC ，其中从 B 顶点引出 n 条射线，与 AC 边交于 n 个点，又从 C 顶点引出 m 条射线，与 AB 边交于 m 个点。所有这些线条在三角形内一共产生了 mn 个交点。现在，在每一个交点处都画一个小圆，于是每个小圆内都会有两条小线段。对于每一个小圆，我们都随机从下述三个操作中选择一个来执行。</p>
<ul>
<li>擦去 C 点所引射线上的小线段，仅保留 B 点所引射线上的小线段</li>
<li>擦去 B 点所引射线上的小线段，仅保留 C 点所引射线上的小线段 </li>
<li>擦去圆内的全部两条小线段</li>
</ul>
<p>三种操作各自被选中的概率分别为 p 、 q 和 1 &#8211; p &#8211; q 。于是，每一个小圆里都最多只留下了一条小线段。</p>
<p class="indent"><img src="http://www.matrix67.com/blogimage_2015/20150523.png" alt="" width="428" /></p>
<p>每条从 B 点出发的线上都有 m 个小圆，这条线在 m 个小圆内都被保留下来了的概率是 p<sup>m</sup> ，因而整条线有断掉之处的概率就是 1 &#8211; p<sup>m</sup> 。从 B 点出发的线一共有 n 条，每条线都有断掉之处的概率就是 (1 &#8211; p<sup>m</sup>)<sup>n</sup> 。因此，至少有一条线完好无缺的概率就是 1 &#8211; (1 &#8211; p<sup>m</sup>)<sup>n</sup> 。类似地，从 C 点出发的 m 条线当中，至少有一条线完好无缺的概率就是 1 &#8211; (1 &#8211; q<sup>n</sup>)<sup>m</sup> 。</p>
<p>但是，从 B 点出发的线条只要有一条是完全连通的，都会使得从 C 点出发的所有线条都断掉；从 C 点出发的线条只要有一条是完全连通的，都会使得从 B 点出发的所有线条都断掉。因此，存在某条从 B 点出发的完好的线，与存在某条从 C 点出发的完好的线，这两个事件是互斥的。这说明</p>
<p class="indent">(1 &#8211; (1 &#8211; p<sup>m</sup>)<sup>n</sup>) + (1 &#8211; (1 &#8211; q<sup>n</sup>)<sup>m</sup>) ≤ 1</p>
<p>整理可得</p>
<p class="indent">(1 &#8211; p<sup>m</sup>)<sup>n</sup> + (1 &#8211; q<sup>n</sup>)<sup>m</sup> ≥ 1</p>
<p>这个问题来自 Ross Honsberger 的 More Mathematical Morsels 一书。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6386/feed</wfw:commentRss>
            <slash:comments>24</slash:comments>
        </item>
        <item>
            <title>趣题：无限多层嵌套的逻辑推理</title>
            <link>http://www.matrix67.com/blog/archives/6377</link>
            <comments>http://www.matrix67.com/blog/archives/6377#comments</comments>
            <pubDate>Fri, 22 May 2015 10:13:03 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[无穷]]></category>
            <category><![CDATA[趣题]]></category>
            <category><![CDATA[递归]]></category>
            <category><![CDATA[逻辑]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6377</guid>
            <description>
                <![CDATA[大家一定见过很多“我不知道，我也不知道，我还是不知道，我还是不知道，我知道了，我也知道了”的问题。但是，我想大家一定没有见过下面这样的问题。 A 、 B 两人在主持人 C 的带领下玩一个游戏。 C 向两人宣布游戏规则：“一会儿我会随机产生两个不同的形如 n &#8211; 1/2k &#8211; 1/2k+r 的数，其中 n 、 k 是正整数， r 是非负整数。然后，我会把这两个数分别交给你们。你们每个人都只知道自己手中的数是多少，但不知道对方手中的数是多少。你们需要猜测，谁手中的数更大一些。”这里，我们假设所有人的逻辑推理能力都是无限强的，并且这一点本身也成为了共识。 C 按照规则随机产生了两个数，把它们交给了 A 和 B ，然后问他们是否知道谁手中的数更大。于是有了这样的一段对话。 A ：我不知道。 B ：我也不知道。 A ：我还是不知道。 B ：我也还是不知道。 C ：这样下去是没有用的！可以告诉你们，不管你们像这样来来回回说多少轮，你们仍然都没法知道，谁手中的数更大一些。 A ：哇，这个信息量好像有点儿大！不过，即使知道了这一点，我还是不知道谁手中的数更大。 B ：我也还是不知道。 A ：我继续不知道。 B ：我也继续不知道。 C ：还是套用刚才的话，不管你们像这样继续说多少轮，你们仍然没法知道谁手中的数更大。 A ：哦……不过，我还是不知道谁手中的数更大。 B ：而且我也还是不知道。我们究竟什么时候才能知道呢？ C ：事实上啊，如果我们三个就像这样继续重复刚才的一切——你们俩互相说一堆不知道，我告诉你们这样永远没用，然后你们继续互说不知道，我继续说这不管用——那么不管这一切重复多少次，你们仍然不知道谁手中的数更大！ A ：哇，这次的信息量就真的大了。只可惜，我还是不知道谁的数更大一些。 [&#8230;]]]></description>
            <content:encoded><![CDATA[<p>大家一定见过很多“我不知道，我也不知道，我还是不知道，我还是不知道，我知道了，我也知道了”的问题。但是，我想大家一定没有见过下面这样的问题。</p>
<p>A 、 B 两人在主持人 C 的带领下玩一个游戏。 C 向两人宣布游戏规则：“一会儿我会随机产生两个不同的形如 n &#8211; 1/2<sup>k</sup> &#8211; 1/2<sup>k+r</sup> 的数，其中 n 、 k 是正整数， r 是非负整数。然后，我会把这两个数分别交给你们。你们每个人都只知道自己手中的数是多少，但不知道对方手中的数是多少。你们需要猜测，谁手中的数更大一些。”这里，我们假设所有人的逻辑推理能力都是无限强的，并且这一点本身也成为了共识。 C 按照规则随机产生了两个数，把它们交给了 A 和 B ，然后问他们是否知道谁手中的数更大。于是有了这样的一段对话。 <span id="more-6377"></span></p>
<blockquote><p>A ：我不知道。<br />
B ：我也不知道。<br />
A ：我还是不知道。<br />
B ：我也还是不知道。<br />
C ：这样下去是没有用的！可以告诉你们，不管你们像这样来来回回说多少轮，你们仍然都没法知道，谁手中的数更大一些。<br />
A ：哇，这个信息量好像有点儿大！不过，即使知道了这一点，我还是不知道谁手中的数更大。<br />
B ：我也还是不知道。<br />
A ：我继续不知道。<br />
B ：我也继续不知道。<br />
C ：还是套用刚才的话，不管你们像这样继续说多少轮，你们仍然没法知道谁手中的数更大。<br />
A ：哦……不过，我还是不知道谁手中的数更大。<br />
B ：而且我也还是不知道。我们究竟什么时候才能知道呢？<br />
C ：事实上啊，如果我们三个就像这样继续重复刚才的一切——你们俩互相说一堆不知道，我告诉你们这样永远没用，然后你们继续互说不知道，我继续说这不管用——那么不管这一切重复多少次，你们仍然不知道谁手中的数更大！<br />
A ：哇，这次的信息量就真的大了。只可惜，我还是不知道谁的数更大一些。<br />
B ：我也还是不知道。<br />
A ：是吗？好，那我现在终于知道谁的数更大了。<br />
B ：这样的话，那我也知道了。而且，我还知道我们俩手中的数具体是多少了。<br />
A ：那我也知道了。</p></blockquote>
<p>那么 ， C 究竟把哪两个数给了 A 和 B ？</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>上面的题目明显来自于这样一个老题： C 随机产生了两个不同的正整数，分别交给了 A 、 B ，并让两人猜测谁手中的数更大。然后 A 说不知道， B 说不知道， A 说还是不知道， B 也说还是不知道，然后 A 说知道了， B 说不但知道了，而且这两个数具体是多少都知道了。问这两个数是多少。</p>
<p>解答过程并不复杂。首先， A 说了一个“不知道”。这当然不奇怪，一开始就说“知道了”才奇怪呢。我们不妨反过来想想，什么情况下 A 一开始就会说“知道了”呢？容易想到，这一定是因为 A 手中的数是 1 。由于 C 产生了两个<strong>不同</strong>的<strong>正</strong>整数，因此当 A 手中的数是 1 时，他就知道了 B 手中的数必然更大。然而， A 实际上说的是“不知道”，这说明 A 手中拿到的数不是 1 。也就是说， A 手中的数至少是 2 。</p>
<p>B 听到了 A 的回答后，也推出了这一点。那么，什么情况下 B 会立即说“知道了”呢？当然，如果 B 手中的数是 1 ，他就立即知道 A 手中的数更大了，因为 A 手中的数至少是 2 。另外，如果 B 手中的数是 2 ，他也会立即知道 A 手中的数更大——既然 A 手中的数至少是 2 ，并且又不等于自己手中的数，因而必然更大一些。当然， B 说的实际上是“不知道”，这说明 B 手中的数至少是 3 。</p>
<p>A 听到了 B 的回答后，也推出了这一点。但是， A 又说了个“不知道”。这说明， A 拿到的既不是 2 ，也不是 3 ，否则他都能推出 B 手中的数更大。因此， A 手中的数至少是 4 。同理，根据 B 的下一个“不知道”可以推出， B 手中的数既不是 3 ，也不是 4 ，至少是 5 。此时， A 说“知道了”。这说明， A 手中的数肯定是 4 和 5 当中的一个，他据此推出了 B 手中的数更大。但是， B 为什么能紧接着推出 A 手中的数具体是多少呢？这一定是因为， B 手中的数就是 5 ，因而能断定 A 手中的数只可能是 4 。所以， A 、 B 两人手中的数分别是 4 和 5 。</p>
<p>这就是旧版的题目。它和本文最开头的那个新版的题目有什么联系呢？用下面两张图来说明真是再合适不过了。在旧版的题目中，把两人手中可能的数（也就是 C 能产生出来的数）全都标在数轴上，那大概是这样：</p>
<p><img src="http://www.matrix67.com/blogimage_2015/201505211.png" alt="" width="500" /></p>
<p>而在新版的题目中，把两人手中可能的数（也就是 C 能产生出来的数）全都标在数轴上，则大概是这样：</p>
<p><img src="http://www.matrix67.com/blogimage_2015/201505212.png" alt="" width="600" /></p>
<p>你会发现这种情况非常有意思。最小的一批数是 0, 1/4, 3/8, 7/16, &#8230; ，这样数下去会有无穷多个数。但是，这无穷多个数的后面还有 1/2, 5/8, 11/16 等数，而且这一系列数本身又是无穷多的；在这无穷多个数的后面又还有 3/4, 13/16 等数，它们也有无穷多个……事实上，我们会遇到无穷多个类似于这样的无穷多个数，而最关键的就是，在这无穷多个无穷的后面，还有 1, 5/4, 11/8 等数。在新版的题目中， A 、 B 、 C 之间的游戏就是在这样的“场所”上进行的。</p>
<p>和旧题类似，在新题中，两人一遍又一遍地宣称自己“不知道”，本质上就是对序列 0, 1/4, 3/8, 7/16, &#8230; 从前往后进行排除。然而， C 跳出来说“这样下去是没有用的”，就意味着任何一方手上的数都不可能是该序列里的数，本质上相当于帮两人一下子排除掉了这无穷多种可能。如果此时 A 说自己“知道了”，那一定是因为他手里拿着的是除掉这无穷多个数之后剩下的最小的数，即 1/2 。然而， A 仍然说自己“不知道”，并且 B 也继续说自己“不知道”，并如此往复。此时，他们就相当于是在序列 1/2, 5/8, 11/16, &#8230; 上斗智了。而 C 又说了一遍刚才的话，本质上相当于又帮两人把这一系列数都排除掉了。两人继续开始考虑下一系列数的可能。</p>
<p>最后， C 告诉两人，这个模式重复多少次都不管用。于是，再下一系列的数，再下一系列的数，以及后面无穷多个系列的数，都被排除掉了。两人都知道了，他们手上的数都至少是 1 。当 A 再次说“不知道”的时候，说明他手中的数不是 1 ； B 再次说“不知道”，说明他手中的数既不是 1 也不是 5/4 ； A 说“知道了”，说明他手中的数是 5/4 和 11/8 中的一个； B 连具体的数也推出来了，说明此时 B 手上的数就是 11/8 。所以，两人手上的数分别是 5/4 和 11/8 。</p>
<p>本文的问题出自<a href="http://jdh.hamkins.org/transfinite-epistemic-logic-puzzle-challenge/">这里</a>，有改动。知道序数理论的朋友或许会意识到，这是引入序数概念的一个绝佳的例子。文中的很多细节之处缺乏形式化描述，这使得题目和解答都有商讨的空间。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6377/feed</wfw:commentRss>
            <slash:comments>19</slash:comments>
        </item>
        <item>
            <title>趣题：下一根枕木应该画在哪儿？</title>
            <link>http://www.matrix67.com/blog/archives/6371</link>
            <comments>http://www.matrix67.com/blog/archives/6371#comments</comments>
            <pubDate>Tue, 19 May 2015 04:03:16 +0000</pubDate>
            <dc:creator><![CDATA[admin]]></dc:creator>
            <category><![CDATA[Uncategorized]]></category>
            <category><![CDATA[几何]]></category>
            <category><![CDATA[趣题]]></category>

            <guid isPermaLink="false">http://www.matrix67.com/blog/?p=6371</guid>
            <description>
                <![CDATA[一位画家正在画画。画布上是一望无际的平原，一条笔直的铁路向无限远的地方延伸。画家画了铁路上的两根相邻的枕木，它们在画面上呈两条平行的线段，并且都与地平线平行。这时，画家突然犯难了：根据透视的原理，下一根枕木应该画在哪儿呢？你能帮他确定出下一根枕木的位置吗？ 这里，我们假设陆地是一个无限大的平面，并且铁路上的相邻枕木之间的间距相等。 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 假设两根枕木分别是 AB 和 CD 。容易想到，如果地面上的两条直线交于地平线处，就说明这两条直线是平行的。另外，注意到相邻枕木之间构成了一个个全等的矩形，它们的对角线应该是平行的。于是，我们就有了这样一个方案：延长 BC 与地平线交于点 P ，然后连接 PD ，与左边的铁轨线交于 E 。现在，只需要作一条与已有枕木平行的线段 EF 。线段 EF 就是铁路中的下一根枕木。 这个问题来自 Ross Honsberger 的 More Mathematical Morsels 一书。]]></description>
            <content:encoded><![CDATA[<p>一位画家正在画画。画布上是一望无际的平原，一条笔直的铁路向无限远的地方延伸。画家画了铁路上的两根相邻的枕木，它们在画面上呈两条平行的线段，并且都与地平线平行。这时，画家突然犯难了：根据透视的原理，下一根枕木应该画在哪儿呢？你能帮他确定出下一根枕木的位置吗？</p>
<p><img src="http://www.matrix67.com/blogimage_2015/201505191.png" alt="" width="310" /></p>
<p>这里，我们假设陆地是一个无限大的平面，并且铁路上的相邻枕木之间的间距相等。</p>
<p><span id="more-6371"></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>假设两根枕木分别是 AB 和 CD 。容易想到，如果地面上的两条直线交于地平线处，就说明这两条直线是平行的。另外，注意到相邻枕木之间构成了一个个全等的矩形，它们的对角线应该是平行的。于是，我们就有了这样一个方案：延长 BC 与地平线交于点 P ，然后连接 PD ，与左边的铁轨线交于 E 。现在，只需要作一条与已有枕木平行的线段 EF 。线段 EF 就是铁路中的下一根枕木。</p>
<p><img src="http://www.matrix67.com/blogimage_2015/201505192.png" alt="" width="419" /></p>
<p>这个问题来自 Ross Honsberger 的 More Mathematical Morsels 一书。</p>
]]></content:encoded>
            <wfw:commentRss>http://www.matrix67.com/blog/archives/6371/feed</wfw:commentRss>
            <slash:comments>31</slash:comments>
        </item>
    </channel>
</rss>

        <!-- Dynamic page generated in 0.530 seconds. -->
        <!-- Cached page generated by WP-Super-Cache on 2015-09-11 21:50:11 -->
